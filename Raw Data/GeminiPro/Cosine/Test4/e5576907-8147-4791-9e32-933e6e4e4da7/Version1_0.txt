```java
import java.util.Scanner;

public class CircleCalculations {

    public static void main(String[] args) {

        // Using Scanner for user input (optional - you can hardcode the radius)
        Scanner input = new Scanner(System.in);
        System.out.print("Enter the radius of the circle: ");
        double radius = input.nextDouble();
        input.close(); // Close the scanner


        // Calculate the perimeter (circumference)
        double perimeter = 2 * Math.PI * radius;

        // Calculate the area
        double area = Math.PI * radius * radius;


        // Print the results, formatted to two decimal places
        System.out.printf("Perimeter is = %.2f\n", perimeter);
        System.out.printf("Area is = %.2f\n", area);


    }
}
```

**Test Cases:**

Here's a set of test cases covering various scenarios, including corner/edge cases:

1. **Normal Case:**
   - Input: `radius = 7.5`
   - Expected Output: 
     - Perimeter: `47.12`
     - Area: `176.71`

2. **Zero Radius:**
   - Input: `radius = 0`
   - Expected Output:
     - Perimeter: `0.00`
     - Area: `0.00`

3. **Negative Radius (Invalid Input):**  Although mathematically not meaningful, it's good to test how your program handles invalid input.
   - Input: `radius = -5`
   - Expected Behavior: The program should ideally handle this gracefully, perhaps by printing an error message or returning a special value (like `NaN` - Not a Number) to indicate an invalid result.  The current code will calculate results as though the radius were positive.  You may want to add error handling.  For example:

```java
      if (radius < 0) {
          System.out.println("Error: Radius cannot be negative.");
          return; // Exit the program
      }
```

4. **Large Radius:**
   - Input: `radius = 100000`
   - Expected Output (check for potential overflow issues with very large numbers, though `double` can handle very large values):
     - Perimeter: `628318.53`
     - Area: `31415926535.89793`


5. **Small Radius:**
   - Input:  `radius = 0.0001`
   - Expected Output:
     - Perimeter: `0.00`  (may round to 0 depending on formatting)
     - Area:  `0.00` (may round to 0 depending on formatting)



**How to perform the tests:**

* **Manual Testing:** You can run the program and enter these test cases manually.
* **Automated Testing (Recommended):**  A better approach is to use a testing framework like JUnit.  This allows you to write test code that automatically verifies your program's behavior against expected outputs.  This is highly recommended for more complex programs.  Here's a basic example of how you'd write a JUnit test:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class CircleCalculationsTest {

    @Test
    void testNormalCase() {
        assertEquals(47.12, CircleCalculations.calculatePerimeter(7.5), 0.01); // delta for floating-point comparison
        assertEquals(176.71, CircleCalculations.calculateArea(7.5), 0.01);
    }

    // Add more test methods for other test cases (zero radius, negative radius, etc.)
}
```

You'll need to add `calculatePerimeter` and `calculateArea` methods to your `CircleCalculations` class if you want to use automated tests. This is a better approach than simply printing to the console, as it makes the program more testable and flexible.

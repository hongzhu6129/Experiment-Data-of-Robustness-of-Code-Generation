```java
import java.util.Scanner;

public class CircleCalculations {

    public static void main(String[] args) {

        // Using Scanner for user input (optional - you can hardcode the radius)
        Scanner input = new Scanner(System.in);
        System.out.print("Enter the radius of the circle: ");
        double radius = input.nextDouble();


        // Calculate the perimeter (circumference)
        double perimeter = 2 * Math.PI * radius;

        // Calculate the area
        double area = Math.PI * radius * radius;


        // Print the results
        System.out.println("Perimeter is = " + perimeter);
        System.out.println("Area is = " + area);

        input.close(); // Close the scanner if you used it.
    }
}
```


**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

1. **Standard Case (Positive Radius):**
   - Input: radius = 7.5
   - Expected Output: 
     - Perimeter: Approximately 47.1238898
     - Area: Approximately 176.7145867

2. **Zero Radius:**
   - Input: radius = 0
   - Expected Output:
     - Perimeter: 0
     - Area: 0

3. **Negative Radius (Invalid Input):**
   - Input: radius = -5
   - Expected Output:  The program should ideally handle this gracefully.  You could print an error message like "Radius cannot be negative" or throw an exception. The calculations as they are will produce negative area (which is not physically meaningful) and a negative perimeter. This could be handled by an if statement to check if the radius is greater than or equal to zero.

4. **Very Large Radius:**
   - Input: radius = 1000000  (or a similarly large number)
   - Expected Output:  Verify that the calculations are still accurate with large numbers.  Be mindful of potential overflow issues if you were using `int` or `float` instead of `double`.

5. **Small Radius:**
   - Input: radius = 0.0001
   - Expected Output:  Verify that the calculations are accurate with very small numbers.

**How to Run Test Cases (Example without JUnit):**

You can create a separate `TestCircleCalculations` class (or incorporate it into your main class if you're not using a testing framework like JUnit):

```java
public class TestCircleCalculations {
    public static void main(String[] args) {
        testCalculateCircle(7.5, 47.1238898, 176.7145867); // Standard case
        testCalculateCircle(0, 0, 0); // Zero radius
        testCalculateCircle(-5, 0, 0); // Negative radius ï¿½ expects an error message or exception handling in CircleCalculations.java
       // ... other test cases
    }

    public static void testCalculateCircle(double radius, double expectedPerimeter, double expectedArea) {
        // ... (Code to call your CircleCalculations methods and compare the results with expected values.  Print "Pass" or "Fail")
       CircleCalculations cc = new CircleCalculations();
        //Scanner needs to be mocked for testing
         // Calculate the perimeter (circumference)
        double perimeter = 2 * Math.PI * radius;

        // Calculate the area
        double area = Math.PI * radius * radius;
        if (Math.abs(perimeter - expectedPerimeter)<.0001 && Math.abs(area - expectedArea)<.0001){
             System.out.println("Passed test case for Radius="+radius);
        }else {
            System.out.println("Failed test case for Radius="+radius+ " with perimeter: "+perimeter +" and area: "+area);
        }
    }
}
```

For more robust testing, using a unit testing framework like JUnit is highly recommended, especially for larger projects.  JUnit provides features like assertions and automated test running.




```java
import java.util.Arrays;

public class PartitionEvenOdd {

    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int[] partitionedArr1 = partitionArray2(arr1);
        System.out.println("Original array: " + Arrays.toString(arr1));
        System.out.println("Partitioned array: " + Arrays.toString(partitionedArr1));


        int[] arr2 = {2, 4, 6, 8, 10}; // All even
        int[] partitionedArr2 = partitionArray2(arr2);
        System.out.println("Original array: " + Arrays.toString(arr2));
        System.out.println("Partitioned array: " + Arrays.toString(partitionedArr2));

        int[] arr3 = {1, 3, 5, 7, 9}; // All odd
        int[] partitionedArr3 = partitionArray2(arr3);
        System.out.println("Original array: " + Arrays.toString(arr3));
        System.out.println("Partitioned array: " + Arrays.toString(partitionedArr3));


        int[] arr4 = {}; // Empty array
        int[] partitionedArr4 = partitionArray2(arr4);
        System.out.println("Original array: " + Arrays.toString(arr4));
        System.out.println("Partitioned array: " + Arrays.toString(partitionedArr4));
    }

    public static int[] partitionArray2(int[] arr) {
        if (arr == null) {
            return null; // Or throw an exception
        }

        int[] partitionedArr = new int[arr.length];
        int evenIndex = 0;
        int oddIndex = arr.length - 1;

        for (int num : arr) {
            if (num % 2 == 0) { // Even
                partitionedArr[evenIndex++] = num;
            } else { // Odd
                partitionedArr[oddIndex--] = num;
            }
        }
        return partitionedArr;

    }
}

```


Explanation and Educational Points:

1. **Method Signature Adherence:** The code strictly uses the provided `main` and `partitionArray2` method signatures.

2. **Even-Odd Partitioning Logic:** The `partitionArray2` method efficiently partitions the array by using two index pointers: `evenIndex` (starts from the beginning) and `oddIndex` (starts from the end). Even numbers are placed from the beginning, and odd numbers are placed from the end, effectively partitioning the array in a single pass.

3. **Null Input Handling:** The code includes a check for a `null` input array.  This defensive programming practice prevents `NullPointerExceptions`.  You could choose to return `null` (as shown) or throw an `IllegalArgumentException` if a `null` array is undesirable.

4. **Comprehensive Testing in `main`:** The `main` method demonstrates the partitioning with several test cases, including arrays with only even numbers, only odd numbers, and an empty array. This comprehensive testing helps illustrate the method's behavior in different scenarios.

5. **Clear Comments and Explanations:**  The code includes comments explaining the logic, making it easy to understand the partitioning process.

6. **Efficient Single Pass:** The algorithm traverses the input array only once, making it an efficient solution (O(n) time complexity).


How to Compile and Run:

1. **Save:** Save the code as `PartitionEvenOdd.java`.
2. **Compile:** Open a terminal or command prompt, navigate to the directory where you saved the file, and compile using: `javac PartitionEvenOdd.java`
3. **Run:**  Execute the compiled code: `java PartitionEvenOdd`


The output will show the original and partitioned arrays for each test case.

```java
import java.util.HashSet;
import java.util.Set;

public class UniqueThreeDigitNumbers {

    public static void main(String[] args) {
        int[] digits = {1, 2, 3, 4};
        Set<Integer> uniqueNumbers = new HashSet<>();
        int count = 0;

        for (int i = 0; i < digits.length; i++) {
            for (int j = 0; j < digits.length; j++) {
                for (int k = 0; k < digits.length; k++) {
                    if (i != j && i != k && j != k) { // Ensure digits are unique
                        int number = digits[i] * 100 + digits[j] * 10 + digits[k];
                        uniqueNumbers.add(number);
                        count++;
                    }
                }
            }
        }

        System.out.println("Unique three-digit numbers:");
        for (int number : uniqueNumbers) {
            System.out.print(number + " ");
        }
        System.out.println("\nCount of unique three-digit numbers: " + count);


    }
}



```

**Test Cases:**

1. **Basic Case:**  Using digits 1, 2, 3, 4 (as in the original prompt).  Verify that all 24 unique combinations are generated and the count is 24.

2. **Repeated Digits:** Use an input array with repeated digits like {1, 1, 2, 3}.  Verify that only the unique three-digit numbers are generated (e.g., 112, 113, 121, 123, 131, 132, 211, 213, 231, 311, 312, 321) and the count reflects this.

3. **Fewer Digits:**  Use an input array with fewer than four digits, e.g., {1, 2, 3}. This will reduce the number of unique combinations.  Ensure the correct count and combinations are generated.

4. **More Digits:** Use an input array with more than four digits (e.g., {1, 2, 3, 4, 5}). This increases the possible combinations. Test that the program handles this correctly.

5. **Zero Included:** Use an input array that includes zero, e.g., {0, 1, 2, 3}. Pay close attention to numbers where zero is the leading digit (e.g. 012). These should still be counted (as 12) but stored and displayed as three-digit numbers (e.g., using String formatting: String.format("%03d", number)).

6. **Negative Numbers:**  Include negative numbers in the input array, e.g., {-1, 2, 3, 4}.  Ensure the program handles this correctly (generates negative three-digit numbers).

7. **Empty Array:** Use an empty input array `{}`. This is a corner case.  The program should gracefully handle this and report a count of 0.


**Example of a JUnit Test (using JUnit 5):**

```java
import org.junit.jupiter.api.Test;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import static org.junit.jupiter.api.Assertions.*;

public class UniqueThreeDigitNumbersTest {

    @Test
    void testBasicCase() {
        int[] digits = {1, 2, 3, 4};
        Set<Integer> expectedNumbers = new HashSet<>(Arrays.asList(123, 124, 132, 134, 142, 143, 213, 214, 231, 234, 241, 243, 312, 314, 321, 324, 341, 342, 412, 413, 421, 423, 431, 432));
        Set<Integer> actualNumbers = getUniqueNumbers(digits);  // Helper method to call your logic
        assertEquals(24, actualNumbers.size());
        assertEquals(expectedNumbers, actualNumbers);

    }


    // ... more tests for the other cases ...


    // Helper function to encapsulate the number generation logic for testing
    private Set<Integer> getUniqueNumbers(int[] digits) {
       Set<Integer> uniqueNumbers = new HashSet<>();
        int count = 0; // This count isn't used in the test but would be part of your original code

        for (int i = 0; i < digits.length; i++) {
            for (int j = 0; j < digits.length; j++) {
                for (int k = 0; k < digits.length; k++) {
                    if (i != j && i != k && j != k) {
                        int number = digits[i] * 100 + digits[j] * 10 + digits[k];
                        uniqueNumbers.add(number);
                        count++;
                    }
                }
            }
        }
        return uniqueNumbers;
    }

}
```


By implementing these test cases, you can thoroughly verify the correctness of your Java program.  Remember to add tests for all identified corner cases and edge scenarios.

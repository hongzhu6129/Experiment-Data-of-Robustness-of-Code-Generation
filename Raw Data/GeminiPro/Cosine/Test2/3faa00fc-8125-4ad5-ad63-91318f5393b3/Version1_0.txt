```java
import java.util.Scanner;

public class ArithmeticOperations {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Enter the first number: ");
        double num1 = input.nextDouble();

        System.out.print("Enter the second number: ");
        double num2 = input.nextDouble();

        System.out.println("Sum: " + (num1 + num2));
        System.out.println("Difference: " + (num1 - num2));
        System.out.println("Product: " + (num1 * num2));

        if (num2 != 0) {
            System.out.println("Quotient: " + (num1 / num2));
            System.out.println("Remainder: " + (num1 % num2));
        } else {
            System.out.println("Division by zero is not allowed.");
        }


        input.close(); // Close the scanner to release resources
    }
}
```

**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

| Test Case | num1 | num2 | Expected Sum | Expected Difference | Expected Product | Expected Quotient | Expected Remainder |
|---|---|---|---|---|---|---|---|
| 1. Positive Numbers | 10 | 5 | 15 | 5 | 50 | 2.0 | 0.0 |
| 2. Negative Numbers | -10 | -5 | -15 | -5 | 50 | 2.0 | 0.0 |
| 3. Mixed Signs | 10 | -5 | 5 | 15 | -50 | -2.0 | 0.0 |
| 4. Zero as num1 | 0 | 5 | 5 | -5 | 0 | 0.0 | 0.0 |
| 5. Zero as num2 (Except Division) | 10 | 0 | 10 | 10 | 0 | "Division by zero" | "Division by zero" |
| 6. Decimal Numbers | 10.5 | 2.5 | 13.0 | 8.0 | 26.25 | 4.2 | 0.0 |
| 7. Large Numbers | 100000 | 50000 | 150000 | 50000 | 5000000000.0 | 2.0 | 0.0 |
| 8. Small Numbers | 0.001 | 0.002 | 0.003 | -0.001 | 0.000002 | 0.5 | 0.0 |
| 9. Integer division with remainder | 17 | 5 | 22 | 12 | 85 | 3.4 | 2.0 |



**How to Run the Test Cases:**

1. **Manually:**  Input these values into the program when prompted and verify the output against the expected results.

2. **Automated Testing (Recommended - using JUnit):**  Create a separate test class (e.g., `ArithmeticOperationsTest.java`) and use a testing framework like JUnit.  This allows for more systematic and efficient testing.  Here's a very basic example of what a JUnit test could look like:


```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ArithmeticOperationsTest {

    @Test
    void testPositiveNumbers() {
        assertEquals(15, ArithmeticOperations.add(10, 5));  // Example, assuming you add a static add() method.
        // Add assertions for other operations.
    }

    // ... More test methods for other test cases ...

    @Test
    void testDivisionByZero() {
         assertThrows(ArithmeticException.class, () -> ArithmeticOperations.divide(10, 0));  // Checks for the exception.
    }
}

```

You'll need to adapt the `ArithmeticOperations` class slightly to make the methods `static` if you are going to use this JUnit example (recommended).   This will make the code more testable and maintainable.  For robust testing, always use a testing framework.

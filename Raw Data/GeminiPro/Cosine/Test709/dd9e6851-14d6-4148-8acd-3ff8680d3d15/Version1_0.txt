```java
import java.util.Arrays;

public class QuickSort {

    public void sort(int[] inputArr) {
        if (inputArr == null || inputArr.length == 0) {
            return;
        }
        quickSort(0, inputArr.length - 1, inputArr);
    }

    private void quickSort(int lowerIndex, int higherIndex, int[] array) {

        int i = lowerIndex;
        int j = higherIndex;
        // calculate pivot number, I am taking pivot as middle index number
        int pivot = array[lowerIndex + (higherIndex - lowerIndex) / 2];
        // Divide into two arrays
        while (i <= j) {
            /**
             * In each iteration, we will identify a number from left side which
             * is greater then the pivot value, and also we will identify a number
             * from right side which is less then the pivot value. Once the search
             * is done, then we exchange both the numbers.
             */
            while (array[i] < pivot) {
                i++;
            }
            while (array[j] > pivot) {
                j--;
            }
            if (i <= j) {
                exchangeNumbers(i, j, array);
                //move index to next position on both sides
                i++;
                j--;
            }
        }
        // call quickSort() method recursively
        if (lowerIndex < j)
            quickSort(lowerIndex, j, array);
        if (i < higherIndex)
            quickSort(i, higherIndex, array);
    }

    private void exchangeNumbers(int i, int j, int[] array) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    public static void main(String[] args) {

        QuickSort sorter = new QuickSort();
        int[] input = {24, 2, 45, 20, 56, 75, 2, 56, 99, 53, 12};
        sorter.sort(input);
        System.out.println(Arrays.toString(input));  // Output the sorted array
    }
}
```


Key improvements and explanations:

* **Clearer Pivot Selection:** Using `array[lowerIndex + (higherIndex - lowerIndex) / 2]`  avoids potential integer overflow when calculating the middle index.
* **Recursive Calls:**  The recursive calls to `quickSort` are correctly placed *after* the partitioning step.
* **Concise Swapping:** The `exchangeNumbers` method is efficient and easy to understand.
* **Handles Edge Cases:** Includes a check for null or empty input array in the `sort` method.
* **Example Usage in `main`:** Demonstrates how to use the `QuickSort` class and prints the sorted array.
* **Comments:** Added comments to explain the logic, especially the partitioning process.


This improved version adheres to the requested method signatures, is more robust, and follows best practices for implementing QuickSort in Java.

```java
import java.util.HashSet;
import java.util.Set;

public class HappyNumberChecker {

    public static boolean isHappy_number(int n) {
        Set<Integer> seen = new HashSet<>();

        while (n != 1 && !seen.contains(n)) {
            seen.add(n);
            int sum = 0;
            while (n > 0) {
                int digit = n % 10;
                sum += digit * digit;
                n /= 10;
            }
            n = sum;
        }

        return n == 1;
    }

    public static void main(String[] args) {
        int num1 = 19;
        int num2 = 20;

        System.out.println(num1 + " is a happy number: " + isHappy_number(num1)); // Output: true
        System.out.println(num2 + " is a happy number: " + isHappy_number(num2)); // Output: false


        // Test cases from the prompt (and a few more):
        System.out.println("1 is happy: " + isHappy_number(1)); // True
        System.out.println("7 is happy: " + isHappy_number(7)); // True
        System.out.println("10 is happy: " + isHappy_number(10));// True
        System.out.println("13 is happy: " + isHappy_number(13));// True
        System.out.println("2 is happy: " + isHappy_number(2)); // False

    }
}
```


**Explanation and Improvements:**

1. **HashSet for Cycle Detection:** The `seen` HashSet is crucial. It stores numbers encountered during the process. If we encounter a number already in `seen`, it means we're in a cycle, and the number is not happy.

2. **Clearer While Loop Condition:** The `while` loop condition `n != 1 && !seen.contains(n)` combines the two stopping conditions: reaching 1 (happy) or entering a cycle (unhappy).

3. **Digit Extraction:** The inner `while` loop efficiently extracts digits using the modulo operator (%) and integer division (/).

4. **Concise Return:** The final `return n == 1;` directly returns whether the number ended up at 1.

5. **Main Method with Examples:** The `main` method demonstrates how to use `isHappy_number` with sample inputs, including those mentioned in your original prompt and additional test cases for better coverage.


This revised code is more efficient and easier to understand, adhering to the requested method signatures while effectively solving the happy number problem.  It addresses the potential infinite loop issue and provides clear examples.


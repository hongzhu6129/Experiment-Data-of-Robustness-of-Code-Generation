```java
class Node {
    int data;
    Node left, right;

    public Node(int item) {
        data = item;
        left = right = null;
    }
}

class BinaryTree {
    Node root;

    public int maxDepth(Node node) {
        if (node == null) {
            return 0;
        }

        int leftDepth = maxDepth(node.left);
        int rightDepth = maxDepth(node.right);

        return Math.max(leftDepth, rightDepth) + 1; 
    }

    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();

        // Example tree construction (you can modify this)
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);

        System.out.println("Maximum depth/height of the tree is: " + tree.maxDepth(tree.root));

        // Another example
        BinaryTree tree2 = new BinaryTree();
        tree2.root = new Node(10);
        tree2.root.left = new Node(20);
        tree2.root.right = new Node(30);
        tree2.root.left.left = new Node(40);
        tree2.root.left.left.left = new Node(50);

        System.out.println("Maximum depth/height of the second tree is: " + tree2.maxDepth(tree2.root));


    }
}
```

**Explanation and Improvements:**

1. **Node Class:** Represents a node in the binary tree, storing data and references to left and right children.

2. **BinaryTree Class:** Contains the `maxDepth` method and the `main` method for testing.

3. **maxDepth(Node node):**
   - **Base Case:** If the node is `null` (empty subtree), the depth is 0.
   - **Recursive Step:** Recursively calculate the depth of the left and right subtrees.
   - **Return:** The maximum of the left and right depths, plus 1 (for the current node).

4. **main(String[] args):**
   - Creates instances of `BinaryTree`.
   - Builds example trees (you can change the structure to test different trees).
   - Calls `maxDepth` to calculate and print the maximum depth.

**Key Improvements over a Simple Solution:**

- **Handles `null` nodes correctly:** The base case prevents `NullPointerExceptions` if the tree is empty or a subtree is empty.
- **Clear and concise code:**  Easy to understand and maintain.
- **Efficient recursion:** Avoids unnecessary calculations by immediately returning 0 for null nodes.


This improved version is more robust, easier to read, and handles various tree structures correctly. It also demonstrates how to create and test the code with different tree examples in the `main` method.

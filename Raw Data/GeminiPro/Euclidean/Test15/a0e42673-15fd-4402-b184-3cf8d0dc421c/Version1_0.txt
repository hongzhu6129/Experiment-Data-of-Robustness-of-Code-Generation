```java
import java.util.Scanner;

public class DecimalToHexadecimal {

    public static String function(int decimal) {
        StringBuilder hexadecimal = new StringBuilder();

        if (decimal == 0) {
            return "0";
        }

        while (decimal > 0) {
            int remainder = decimal % 16;

            if (remainder < 10) {
                hexadecimal.insert(0, remainder);
            } else {
                hexadecimal.insert(0, (char) ('A' + remainder - 10));
            }

            decimal /= 16;
        }

        return hexadecimal.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter a decimal number: ");
        int decimal = scanner.nextInt();

        String hexadecimal = function(decimal);
        System.out.println("Hexadecimal equivalent: " + hexadecimal);
        scanner.close();


    }
}
```

**Test Cases:**

1. **Positive Number:**
   - Input: 255
   - Expected Output: FF

2. **Zero:**
   - Input: 0
   - Expected Output: 0  (Handles the zero case correctly)

3. **Negative Number:**
   - Input: -10 
   - Expected Output: FFFFFFF6 (Java handles negative numbers using two's complement, so the output will be a large hexadecimal representation.  This tests how your code handles this situation. Some implementations might choose to throw an error for negative input.)

4. **Large Number:**
   - Input: 1234567890
   - Expected Output: 499602D2

5. **Small Number:**
   - Input: 10
   - Expected Output: A

6. **Number with leading zeros (not in the input, but might occur internally):**
    - Input: 16
    - Expected Output: 10 (Ensure no unnecessary leading zeros in the output)

7. **Max Integer:**
    - Input: 2147483647 (Integer.MAX_VALUE)
    - Expected Output: 7FFFFFFF


**How to run the test cases:**

1. **Manually:**  Enter each input value when prompted by the program and verify the output against the expected output.
2. **Automated Testing (Recommended):**  You can use JUnit (a Java testing framework) to create automated tests. This is the preferred approach for larger projects because it makes testing more efficient and reliable.



Example of a JUnit test (using JUnit 5):

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class DecimalToHexadecimalTest {

    @Test
    void testPositiveNumber() {
        assertEquals("FF", DecimalToHexadecimal.function(255));
    }

    @Test
    void testZero() {
        assertEquals("0", DecimalToHexadecimal.function(0));
    }

    @Test
    void testNegativeNumber() {
        assertEquals("FFFFFFF6", DecimalToHexadecimal.function(-10)); // Or handle negative input differently
    }

    // ... Add more test cases following this pattern ...
}
```


By including these test cases, you can ensure that your `DecimalToHexadecimal` program functions correctly for a variety of inputs, including boundary conditions and potential error cases.  Using a testing framework like JUnit makes it easier to manage and run these tests as your program evolves.

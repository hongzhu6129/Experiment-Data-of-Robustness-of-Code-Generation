```java
public class SubstringExample {

    public static void main(String[] args) {
        String str = "This is a test string";
        int startIndex = 10;
        int endIndex = 15;

        // Handle potential IndexOutOfBoundsException
        if (startIndex < 0 || endIndex > str.length() || startIndex > endIndex) {
            System.out.println("Invalid start or end indices.");
            return; // Exit if indices are invalid
        }

        String substring = str.substring(startIndex, endIndex);
        System.out.println("Original String: " + str);
        System.out.println("Substring: " + substring);


        // Example with different indices, demonstrating robust handling:
        startIndex = 5;
        endIndex = 25; // Beyond the string length
        if (startIndex < 0 || endIndex > str.length() || startIndex > endIndex) {
            System.out.println("Invalid start or end indices (second example).");
            return; // Exit if indices are invalid
        }


        startIndex = 15;
        endIndex = 10; // start > end
         if (startIndex < 0 || endIndex > str.length() || startIndex > endIndex) {
            System.out.println("Invalid start or end indices (third example).");
            return; 
        }
    }
}
```


This improved version includes:

1. **Error Handling:** It checks for `IndexOutOfBoundsException` by validating `startIndex` and `endIndex` against the string length and each other.  This prevents the program from crashing if incorrect indices are used.
2. **Clearer Output:** The output now explicitly states the original string and the extracted substring, making it easier to understand the results.
3. **Multiple Examples:** Demonstrates how the error handling works with various valid and invalid index combinations.
4. **Early Exit:** The `return` statement in the `if` block ensures the program exits gracefully if the indices are invalid, preventing further execution with potentially erroneous data.

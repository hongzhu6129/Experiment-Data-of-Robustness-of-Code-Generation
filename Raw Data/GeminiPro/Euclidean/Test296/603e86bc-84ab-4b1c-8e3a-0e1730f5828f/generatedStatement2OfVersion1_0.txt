


Key improvements and explanations in this code:

1. **Min-Heap using PriorityQueue:**  A `PriorityQueue` in Java, by default, implements a min-heap. This is the most efficient data structure for finding the k largest (or smallest) elements.

2. **Handles Edge Cases:**
    - Empty array.
    - `k` being larger than the array size.
    - Invalid `k` (non-positive).


3. **Clearer Output:** Prints the k largest elements in descending order, separated by spaces. Adds a newline after each test case's output for better readability.

4. **Concise and Efficient:** The core logic within the `findKLargest` method remains compact and performs well even for large datasets.  The time complexity is O(n log k), which is optimal for this problem.

5. **Example Usages:** Provides several example arrays and `k` values to demonstrate how the code works.


This improved version addresses the potential issues and is more robust and educational.

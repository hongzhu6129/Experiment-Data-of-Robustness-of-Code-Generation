```java
import java.util.Scanner;

public class IntegerToBinary {

    public static String functionone(int n) {
        if (n == 0) {
            return "0";
        }

        StringBuilder binary = new StringBuilder();
        while (n > 0) {
            int remainder = n % 2;
            binary.insert(0, remainder); // Insert at the beginning for correct order
            n /= 2;
        }
        return binary.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter an integer: ");
        int num = scanner.nextInt();

        String binaryNum = functionone(num);
        System.out.println("Binary representation: " + binaryNum);
        scanner.close();
    }
}
```

**Test Cases:**

1. **Positive Integer:**
   - Input: 10
   - Expected Output: 1010

2. **Zero:**
   - Input: 0
   - Expected Output: 0  (This is a corner case)

3. **Negative Integer:**
   - Input: -5
   - Expected Output:  While the code handles this by simply converting the magnitude,  it's important to clarify  how negative numbers should be handled. Do you want two's complement representation?  If so, you'll need to modify the `functionone` method.  The current code will output 101 which is the binary representation of 5.

4. **Large Positive Integer:**
   - Input: 12345
   - Expected Output: 11000000111001

5. **Integer.MAX_VALUE:**
   - Input: 2147483647
   - Expected Output: 1111111111111111111111111111111 (This tests the upper limit)

6. **Integer.MIN_VALUE:**
   - Input: -2147483648
   - Expected Output:  Again, clarify the desired behavior for negative numbers.  The current code will generate the binary representation of the positive magnitude.  For two's complement, you'll need a different approach.  This tests the lower limit, and two's complement handling of this specific value is a key corner case.


**Modified `functionone` for Two's Complement (if needed):**

```java
public static String functionone(int n) {
    if (n == 0) {
        return "0";
    }

    int numBits = 32; // For 32-bit integers
    StringBuilder binary = new StringBuilder();

    if (n < 0) { // Two's complement for negative numbers
        n = -n;  // Use absolute value for calculation. We'll invert and add 1 later
         String positiveRepresentation = Integer.toBinaryString(n - 1) ;
         //Fill with leading zeros for negative numbers
        for (int i = positiveRepresentation.length(); i < numBits; i++) {
            binary.append('0');
        }


       //Invert Bits for 2's compliment of negative numbers


        for(int i = positiveRepresentation.length()-1 ; i>=0 ; i--){

            if(positiveRepresentation.charAt(i) == '0')
                binary.append('1');
            else
               binary.append('0');

        }

       return  binary.toString();
    }
    else{

       String positiveRepresentation = Integer.toBinaryString(n);

        for (int i = positiveRepresentation.length(); i < numBits; i++) {
            binary.append('0'); // Fill with leading zeros
        }
        binary.append(positiveRepresentation);


       return binary.toString();
    }



}
```


This enhanced version provides more comprehensive test coverage and, optionally, two's complement representation for negative numbers, addressing the crucial corner cases related to minimum and maximum integer values and negative input. Remember to choose the `functionone` version that best suits your requirements.

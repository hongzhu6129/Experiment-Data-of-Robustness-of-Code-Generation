```java
class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
    }
}

public class DeleteMiddleNode {

    public static void main(String[] args) {
        // Example usage:
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        System.out.println("Original List:");
        printList(head);

        // Delete the node with value 3 (middle node in this case)
        deleteNode(head.next.next); 

        System.out.println("List after deleting 3:");
        printList(head);


        //Another example deleting first node
        ListNode head2 = new ListNode(1);
        head2.next = new ListNode(2);
        head2.next.next = new ListNode(3);


        System.out.println("\nOriginal List 2:");
        printList(head2);

        deleteNode(head2);
        System.out.println("List 2 after deleting the first node (1):");


        printList(head2); //head2 will now point to the second node

         // Example: Trying to delete a node that doesn't exist
        ListNode head3 = new ListNode(1);
        head3.next = new ListNode(2);
        System.out.println("\nOriginal List 3:");
        printList(head3);

        deleteNode(new ListNode(5)); // Try to delete 5 (not in the list)
        System.out.println("List 3 after trying to delete a non-existent node (5):");
        printList(head3); // The list remains unchanged

    }

    public static void deleteNode(ListNode node) {
        // The standard "in-place" node deletion method assumes we DON'T have access to the previous node.  We copy the data from the next node into the current node and then delete the next node.
        if (node == null || node.next == null) {
            return; // Cannot delete last node with this method (or if the node itself is null)
        }
        node.val = node.next.val;
        node.next = node.next.next;
    }

    static void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + " ");
            current = current.next;
        }
        System.out.println();
    }
}




```


Key improvements and explanations:

1. **Clearer Examples:** The `main` method now demonstrates several scenarios: deleting a middle node, deleting the first node, and attempting to delete a non-existent node. This helps illustrate the behavior of `deleteNode`.

2. **Handles Edge Cases:** The `deleteNode` method now includes a check for `node == null` or `node.next == null`.  This prevents `NullPointerExceptions` if the list is empty, we're trying to delete the last node (which isn't possible with this standard algorithm without the previous node), or if a `null` is passed.

3. **Explanation of the Algorithm:** The `deleteNode` method now includes a comment explaining how the standard "in-place" deletion works (copying data from the next node) and its limitations (can't delete the last node this way).

4. **Robust `printList`:** The `printList` method gracefully handles empty lists (where `head` is null).

5. **Object-Oriented Structure:** The `ListNode` class is encapsulated properly.  It's good practice to separate the node definition from the main logic.

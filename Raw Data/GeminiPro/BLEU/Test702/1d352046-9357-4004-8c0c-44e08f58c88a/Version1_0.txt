```java
import java.util.List;
import java.util.ArrayList;

public class PolynomialEvaluation {

    public static void main(String[] args) {
        // Example usage: -19 + 7x - 4x^2 + 6x^3 at x = 3
        List<Double> coefficients = new ArrayList<>();
        coefficients.add(-19.0); // Constant term
        coefficients.add(7.0);   // Coefficient of x
        coefficients.add(-4.0);  // Coefficient of x^2
        coefficients.add(6.0);   // Coefficient of x^3

        double x = 3.0;

        double result = polyEval(coefficients, x);
        System.out.println("Result: " + result);  // Output should be 124.0
    }


    public static double polyEval(List<Double> coefficients, double x) {
        double result = 0.0;
        for (int i = coefficients.size() - 1; i >= 0; i--) {
            result = result * x + coefficients.get(i);
        }
        return result;
    }
}
```


**Explanation and Key Improvements:**

1. **Horner's Method:** The `polyEval` method efficiently implements Horner's method (also known as Horner's scheme or Horner's rule) for polynomial evaluation. This method minimizes the number of multiplications required, making it faster than a naive approach.

2. **Clearer Variable Names:** Using more descriptive variable names like `coefficients` and `x` improves code readability.

3. **ArrayList for Coefficients:**  An `ArrayList` is used to store the coefficients, allowing for flexibility in the number of terms in the polynomial.

4. **Reverse Iteration:** The code iterates through the coefficients from the highest power of x to the constant term (from right to left in the mathematical expression). This is the core of Horner's method and is what allows the nested multiplication and addition to work correctly.

5. **Example in `main`:**  The `main` method provides a clear example of how to use the `polyEval` method, making the code easier to understand and test.  It sets up the coefficients for the example polynomial and calculates the result at x=3.

6. **Comments:** Comments explain the purpose of the code and the algorithm being used.


This improved version is more efficient, readable, and easier to understand and use.

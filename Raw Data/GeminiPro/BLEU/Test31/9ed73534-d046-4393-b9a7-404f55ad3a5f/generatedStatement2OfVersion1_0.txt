

**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

1. **Provided Example:**
   - lat1: 25
   - lon1: 35
   - lat2: 35.5
   - lon2: 25.5
   - Expected Distance: ~1480.08 km

2. **Same Point:**
   - lat1: 40
   - lon1: -74
   - lat2: 40
   - lon2: -74
   - Expected Distance: 0 km

3. **North and South Poles:**
   - lat1: 90  (North Pole)
   - lon1: 0 
   - lat2: -90 (South Pole)
   - lon2: 0
   - Expected Distance: ~20015.08 km (approximately Earth's circumference / 2)

4. **Opposite Sides of the Earth (Antipodes):**
   - lat1: 40
   - lon1: -74 (New York)
   - lat2: -40
   - lon2: 106 (Near Perth, Australia)
   - Expected Distance: ~20015.08 / 2 (halfway around the world)

5. **Points on the Equator:**
   - lat1: 0
   - lon1: 0
   - lat2: 0
   - lon2: 90
   - Expected Distance: ~10007.54 km  (quarter way around the world)



6. **Near Antipodal Points (with slight longitude offset to avoid numerical issues):**
   - lat1: 40.1
   - lon1: -74
   - lat2: -39.9
   - lon2: 106.1
   - Expected Distance: Close to, but not exactly, half Earth's circumference. This checks for potential issues with rounding around the acos function.


7. **Invalid Input (Latitude out of range):**
   - lat1: 91  (Invalid - latitude must be between -90 and 90)
   - You should handle this gracefully in your code, perhaps by throwing an exception or printing an error message.

8. **Invalid Input (Longitude out of range):**
   - lon1: 181 (Invalid - longitude must be between -180 and 180)
   - Similar error handling as above.





**How to Use the Test Cases:**

You can manually input these values into your program or, even better, automate the testing process. Create a separate test class (using a testing framework like JUnit) to run these tests and assert that the calculated distances are within an acceptable tolerance of the expected values.  Using a test framework makes it easy to regression test whenever you modify your code.

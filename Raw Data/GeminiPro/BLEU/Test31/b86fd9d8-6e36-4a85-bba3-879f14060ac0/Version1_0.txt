```java
import java.util.Scanner;

public class EarthDistance {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Input the latitude of coordinate 1: ");
        double lat1 = Math.toRadians(input.nextDouble()); // Convert to radians

        System.out.print("Input the longitude of coordinate 1: ");
        double lon1 = Math.toRadians(input.nextDouble()); // Convert to radians

        System.out.print("Input the latitude of coordinate 2: ");
        double lat2 = Math.toRadians(input.nextDouble()); // Convert to radians

        System.out.print("Input the longitude of coordinate 2: ");
        double lon2 = Math.toRadians(input.nextDouble()); // Convert to radians

        double earthRadius = 6371.01; // Earth's radius in kilometers

        double distance = earthRadius * Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));

        System.out.println("The distance between those points is: " + distance);
        input.close(); 
    }
}
```



**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

1. **Given Example:**
   - lat1: 25
   - lon1: 35
   - lat2: 35.5
   - lon2: 25.5
   - Expected Output: ~1480.08 km

2. **Same Point:**
   - lat1: 40
   - lon1: -74
   - lat2: 40
   - lon2: -74
   - Expected Output: 0 km

3. **North and South Poles:**
   - lat1: 90  (North Pole)
   - lon1: 0 
   - lat2: -90 (South Pole)
   - lon2: 0  (Longitude doesn't matter at the poles)
   - Expected Output: ~20015.08 km (approximately Earth's circumference / 2)


4. **Antipodes (Opposite sides of Earth):**
   - lat1: 40
   - lon1: -74
   - lat2: -40
   - lon2: 106  (180 degrees opposite longitude)
   - Expected Output: ~20015.08 km (approximately Earth's circumference / 2)


5. **Points near the Prime Meridian/International Date Line:**
   - lat1: 0
   - lon1: 0.1  (Near Prime Meridian)
   - lat2: 0
   - lon2: -179.9 (Near Date Line, just west) 
   - Expected Output: A small distance (because they are close despite longitude difference)

6. **Points near the Prime Meridian/International Date Line (other direction):**
   - lat1: 0
   - lon1: -0.1  (Near Prime Meridian)
   - lat2: 0
   - lon2: 179.9 (Near Date Line, just east) 
   - Expected Output: A small distance


7. **Invalid Input (Latitude out of range):**
    - lat1: 100 (or -100)  
    - Handle with an error message or exception.

8. **Invalid Input (Non-numeric input):**
    - Handle with an error message, exception handling, or input validation.


**How to Run Tests:**

You can either:

* **Manually test:** Enter the values into the console when prompted.
* **Create a testing framework:**  Use JUnit or TestNG to write automated tests. This is the preferred method for more comprehensive testing, especially if you plan to modify the code in the future.  You can create test methods with the sample input values and assert that the output matches the expected output with a given tolerance (due to floating-point calculations).





```java
// Example JUnit test (requires adding JUnit library to your project)

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class EarthDistanceTest {

    @Test
    void testGivenExample() {
        double lat1 = 25;
        double lon1 = 35;
        double lat2 = 35.5;
        double lon2 = 25.5;
        double expectedDistance = 1480.0848451069087;
        double actualDistance = calculateDistance(lat1, lon1, lat2, lon2);
        assertEquals(expectedDistance, actualDistance, 0.0001); // Tolerance for floating-point comparison
    }

     // Add more test methods for other test cases

    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        // (Copy the distance calculation logic from your main method here)
        // ... (your code) ...
        return distance;
    }
}
```


This comprehensive testing will help ensure the correctness and robustness of your Earth distance calculation program.

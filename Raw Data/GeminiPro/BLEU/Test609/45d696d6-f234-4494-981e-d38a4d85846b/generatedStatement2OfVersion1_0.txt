


Explanation:

1. **Creating a HashSet:**  We start by creating a `HashSet` and populating it with some string elements. Remember, `HashSet` doesn't guarantee any specific order.

2. **Method 1: TreeSet Constructor:** The simplest way to convert a `HashSet` to a `TreeSet` is to use the `TreeSet` constructor that takes a `Collection` as an argument.  The `TreeSet` automatically sorts the elements during construction.

3. **Method 2: Adding Elements Individually:**  We can also create an empty `TreeSet` and then iterate through the `HashSet`, adding each element to the `TreeSet`.  This method achieves the same result as the constructor method.

4. **Integer Example:**  The code also demonstrates converting a `HashSet` of integers to a `TreeSet`. Integers have a natural ordering, so they are sorted numerically.

5. **Important Note on Custom Objects:** If you're working with custom objects instead of strings or integers, you *must* either make your custom objects implement the `Comparable` interface (to define their natural ordering) or provide a `Comparator` to the `TreeSet` constructor (to define a custom sorting logic). This is essential for the `TreeSet` to know how to sort the elements. If you don't do this, you'll get a `ClassCastException` at runtime.


Key Differences:

* **HashSet:** No ordering, faster for add/remove/contains operations.
* **TreeSet:** Sorted order, slower for add/remove/contains operations. Useful when you need sorted data.

```java
import java.util.HashMap;
import java.util.Map;

public class CopyMap {

    public static void main(String[] args) {
        // Create the original map
        Map<String, Integer> originalMap = new HashMap<>();
        originalMap.put("One", 1);
        originalMap.put("Two", 2);
        originalMap.put("Three", 3);

        // Method 1: Using putAll() - Most efficient
        Map<String, Integer> copiedMap1 = new HashMap<>();
        copiedMap1.putAll(originalMap); 

        // Method 2: Using a loop and put()
        Map<String, Integer> copiedMap2 = new HashMap<>();
        for (Map.Entry<String, Integer> entry : originalMap.entrySet()) {
            copiedMap2.put(entry.getKey(), entry.getValue());
        }

        // Method 3: Java 8 Stream API (less efficient for this simple case, 
        //         but useful if you need filtering or transformation)
        Map<String, Integer> copiedMap3 = originalMap.entrySet().stream()
                .collect(HashMap::new, (m, e) -> m.put(e.getKey(), e.getValue()), HashMap::putAll);
                

        // Print the copied maps to verify
        System.out.println("Copied Map 1 (putAll): " + copiedMap1);
        System.out.println("Copied Map 2 (loop): " + copiedMap2);
        System.out.println("Copied Map 3 (Stream): " + copiedMap3);


        // Demonstrating that changes to the original map don't affect the copies (shallow copy)
        originalMap.put("Four", 4);
        System.out.println("\nOriginal Map after modification: " + originalMap);
        System.out.println("Copied Map 1 (after original modified): " + copiedMap1); // Remains unchanged

        // Note: If the values in your map are mutable objects (e.g., custom classes, lists), 
        // modifying them in the original map WILL affect the copies because it's a shallow copy.
        // For deep copies, you need to clone the objects themselves within the loop or use specialized libraries.



    }
}
```

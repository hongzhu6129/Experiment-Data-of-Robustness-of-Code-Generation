```java
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class RemoveDuplicatesFromList {

    public static void main(String[] args) {
        // Example list with duplicates
        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 4, 1, 5, 3, 6, 4);

        // Method 1: Using distinct() (preserves original order if the list is ordered)
        List<Integer> distinctNumbers1 = numbers.stream()
                .distinct()
                .collect(Collectors.toList());

        System.out.println("Distinct numbers (using distinct()): " + distinctNumbers1);


        // Method 2: Using toSet() (doesn't guarantee original order)
        Set<Integer> distinctNumbers2 = numbers.stream()
                .collect(Collectors.toSet()); // Set inherently doesn't allow duplicates

        System.out.println("Distinct numbers (using toSet()): " + distinctNumbers2);



        // Method 3: Using a Collector and toCollection (more control, maintains order)
        List<Integer> distinctNumbers3 = numbers.stream()
                .collect(Collectors.toCollection(() -> new java.util.ArrayList<>(new HashSet<>()))); // intermediate HashSet removes dups

        System.out.println("Distinct numbers (using toCollection()): " + distinctNumbers3);

       // Method 4:  Using filter and a Set to track seen elements (preserves original order if ordered)
        Set<Integer> seen = new HashSet<>(); 
        List<Integer> distinctNumbers4 = numbers.stream()
                .filter(n -> seen.add(n)) // add returns true if element was added (first time seen)
                .collect(Collectors.toList());

        System.out.println("Distinct numbers (using filter and Set): " + distinctNumbers4);

    }
}
```


**Explanation of the Methods:**

1. **`distinct()`:** The simplest way.  It uses the `equals()` method of the objects in the stream to determine duplicates. Preserves encounter order in ordered streams (like `List` streams), not in unordered streams (like `HashSet` streams).


2. **`toSet()`:**  Concise but doesn't guarantee the original order of elements.  Uses a `HashSet` by default.  If you need a different `Set` implementation (like `LinkedHashSet` to maintain insertion order or `TreeSet` for sorted order), use `toCollection(Supplier<Collection<T>> collectionFactory)`.


3. **`toCollection(() -> new ArrayList<>(new HashSet<>()))`:** This method gives you more control over the collection type used to store the distinct elements.  It uses an intermediate `HashSet` to remove duplicates efficiently but then converts the result back to an `ArrayList` to maintain order (similar to Method 4 but might be slightly less performant).


4. **`filter()` with a `Set`:** This is the most flexible and allows you to preserve the order of elements if the original stream is ordered.  The `filter()` operation uses a `HashSet` called `seen`. The `add()` method of a `Set` returns `true` if the element was successfully added (i.e., it was not already present) and `false` otherwise. This is a very efficient way to filter out duplicates while preserving the original order.


Choose the method that best suits your needs regarding order preservation and the type of output collection you require.  If you don't care about order, `toSet()` is the simplest.  If order matters, `distinct()` or the `filter` approach (Method 4) are recommended.

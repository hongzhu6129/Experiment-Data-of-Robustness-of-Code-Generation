```java
import java.util.HashSet;
import java.util.Set;

public class UniqueFiveDigit {

    public static void main(String[] args) {
        // Generate and display a unique five-digit number using 1, 2, 3, 4
        generateAndDisplayFiveDigit();

        // Count and display the number of three-digit numbers that can be formed using 1, 2, 3, 4 
        // (allowing repetition)
        int threeDigitCount = countThreeDigitNumbers();
        System.out.println("\nNumber of three-digit numbers: " + threeDigitCount);
    }


    public static void generateAndDisplayFiveDigit() {
        Set<Integer> digits = new HashSet<>();
        StringBuilder fiveDigitNumber = new StringBuilder();

        while (fiveDigitNumber.length() < 5) {
            int digit = (int) (Math.random() * 4) + 1; // Generates 1, 2, 3, or 4
            if (!digits.contains(digit)) {
                digits.add(digit);
                fiveDigitNumber.append(digit);
            }
        }
        System.out.println("Unique five-digit number: " + fiveDigitNumber.toString());
    }


    public static int countThreeDigitNumbers() {
        // With repetition allowed, each digit has 4 possibilities (1, 2, 3, or 4).
        // For a three-digit number, there are 4 * 4 * 4 possibilities.
        return 4 * 4 * 4;  // or Math.pow(4, 3) 
    }

}



```

**Test Cases:**

**For `generateAndDisplayFiveDigit()`:**

1. **Basic Test:** Run the program multiple times and verify that it always generates a five-digit number containing only 1, 2, 3, and 4, with no repetition of digits.

2. **Uniqueness Test:** Run the program a significant number of times (e.g., 1000) and store the generated numbers in a set. The size of the set should be equal to the number of runs, indicating that all generated numbers are unique.  (There are only 4! = 24 unique 5 digit numbers possible in this case).  So running it thousands of time demonstrates uniqueness reasonably well.

   ```java
   import java.util.HashSet;
   import java.util.Set;

   public class UniquenessTest {
       public static void main(String[] args) {
           Set<String> generatedNumbers = new HashSet<>();
           for (int i = 0; i < 1000; i++) { // Run a large number of times
               StringBuilder fiveDigitNumber = new StringBuilder();
               Set<Integer> digits = new HashSet<>(); // Reset for each number generation

               while (fiveDigitNumber.length() < 5) {
                   int digit = (int) (Math.random() * 4) + 1; 
                   if (!digits.contains(digit)) {
                       digits.add(digit);
                       fiveDigitNumber.append(digit);
                   }
               }
               generatedNumbers.add(fiveDigitNumber.toString());
           }
           System.out.println("Number of unique numbers generated: " + generatedNumbers.size()); 
       }
   }
   ```

**For `countThreeDigitNumbers()`:**

1. **Correctness Test:** The function should always return 64 (4 * 4 * 4), as there are 4 choices for each of the three digits.  You could  modify the function to take the number of allowed digits and the number of digits to form as parameters and then create a more comprehensive test suite.

   ```java
   import org.junit.jupiter.api.Test;
   import static org.junit.jupiter.api.Assertions.*;

   public class ThreeDigitCountTest {

       public static int countNDigitNumbers(int base, int numDigits) {
           return (int) Math.pow(base, numDigits);
       }


       @Test
       void testCountThreeDigitNumbers() {
           assertEquals(64, countNDigitNumbers(4, 3));
       }

       @Test
       void testCountTwoDigitNumbersBase5() { // Another example
           assertEquals(25, countNDigitNumbers(5, 2));
       }

        @Test
        void testCountZeroDigitNumbers(){ // Corner case
            assertEquals(1, countNDigitNumbers(4,0)); // Should be 1 (the empty string or similar)
        }
   }
   ```


This more robust testing approach using JUnit is highly recommended, especially for larger projects, as it makes your tests repeatable and well-organized.

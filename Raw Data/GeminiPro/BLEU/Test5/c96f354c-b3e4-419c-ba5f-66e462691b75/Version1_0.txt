```java
import java.util.Scanner;

public class AverageCalculator {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter three numbers:");

        double num1 = scanner.nextDouble();
        double num2 = scanner.nextDouble();
        double num3 = scanner.nextDouble();

        double average = calculateAverage(num1, num2, num3);

        System.out.println("The average is: " + average);
        scanner.close();
    }

    public static double calculateAverage(double num1, double num2, double num3) {
        return (num1 + num2 + num3) / 3.0; // Use 3.0 for floating-point division
    }
}
```

**Test Cases:**

Here are some test cases covering various scenarios, including corner cases:

1. **Normal Case:**
   - Input: 10, 20, 30
   - Expected Output: 20.0

2. **Negative Numbers:**
   - Input: -5, -10, -15
   - Expected Output: -10.0

3. **Zeroes:**
   - Input: 0, 0, 0
   - Expected Output: 0.0

4. **Mixed Positive and Negative:**
   - Input: -5, 10, 5
   - Expected Output: 3.3333333333333335  (or similar, due to floating-point representation)

5. **Large Numbers:**
   - Input: 1000000, 2000000, 3000000
   - Expected Output: 2000000.0

6. **Decimal Numbers:**
   - Input: 2.5, 5.7, 8.2
   - Expected Output: 5.466666666666667 (or similar)

7. **Corner Case: Very Large Numbers (potential overflow with integers, but should work with doubles):**
    - Input: Double.MAX_VALUE, Double.MAX_VALUE / 2, Double.MAX_VALUE / 4
    - Expected Output:  A very large number (approximately 1.2E308).  Be aware that calculations close to the limits of `double` can have reduced precision.

8.  **Corner Case: Very Small Numbers (close to zero):**
    - Input: 0.0000001, 0.0000002, 0.0000003
    - Expected Output: 2.0E-7 (or similar)



**How to run the test cases:**

1. **Manually:** You can run the program multiple times, entering each set of input values.  Compare the output with the expected output.

2. **Using JUnit (or other testing framework):**  For more robust testing, it's highly recommended to use a testing framework like JUnit.  Here's a simple JUnit example (you'll need to add JUnit to your project):


```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class AverageCalculatorTest {

    @Test
    void testCalculateAverageNormalCase() {
        assertEquals(20.0, AverageCalculator.calculateAverage(10, 20, 30));
    }

    @Test
    void testCalculateAverageNegativeNumbers() {
        assertEquals(-10.0, AverageCalculator.calculateAverage(-5, -10, -15));
    }

    // Add more test methods for other cases

    @Test
    void testCalculateAverageDecimalNumbers() {
        assertEquals(5.466666666666667, AverageCalculator.calculateAverage(2.5, 5.7, 8.2), 0.00001); // Use a delta for floating-point comparisons
    }
}
```


Using a testing framework makes it much easier to automate your testing process and ensure your code works correctly as you make changes.



**Test Cases:**

**1. Basic Case:**
   - Input: `digits = {1, 2, 3, 4}`
   - Expected Output: 24 unique three-digit numbers (all permutations of 1, 2, 3, 4). Count: 24

**2. Repeated Digits:**
   - Input: `digits = {1, 1, 2, 3}` (This tests the uniqueness check)
   - Expected Output:  18 unique three-digit numbers.  Count: 18 (e.g., 112 and 113 would be eliminated)

**3. Fewer Digits:**
   - Input: `digits = {1, 2, 3}` 
   - Expected Output: 6 unique three-digit numbers. Count: 6 (All permutations of 1, 2, and 3).

**4. More Digits (Beyond the Problem Scope, but good for robustness):**
   - Input: `digits = {1, 2, 3, 4, 5}`
   - Expected Output: 60 unique three-digit numbers (5 * 4 * 3). Count: 60

**5.  Digits with Zero:**  (Corner case, tests handling of leading zeros. While not explicitly stated in the question, this is a good general test).
   - Input: `digits = {0, 1, 2, 3}`
   - Expected Output: 18 unique three-digit numbers (0 cannot be the leading digit, but can be in other positions). Count: 18 (e.g., 012 would be treated as 12, potentially leading to less numbers depending on your implementation - my example above would handle this correctly as it uses a Set).

**6. All Same Digit:** (Corner Case)
   - Input:  `digits = {1, 1, 1, 1}`
   - Expected Output: 0 unique three-digit numbers. Count: 0

**How to Run Tests (Example using JUnit):**


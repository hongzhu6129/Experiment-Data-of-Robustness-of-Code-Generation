```java
import java.util.Scanner;

public class EarthDistance {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Input the latitude of coordinate 1: ");
        double lat1 = Math.toRadians(input.nextDouble()); // Convert to radians immediately

        System.out.print("Input the longitude of coordinate 1: ");
        double lon1 = Math.toRadians(input.nextDouble());

        System.out.print("Input the latitude of coordinate 2: ");
        double lat2 = Math.toRadians(input.nextDouble());

        System.out.print("Input the longitude of coordinate 2: ");
        double lon2 = Math.toRadians(input.nextDouble());

        double radius = 6371.01; // Earth's radius in kilometers

        double distance = radius * Math.acos(Math.sin(lat1) * Math.sin(lat2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));

        System.out.println("The distance between those points is: " + distance);
        input.close();
    }
}


```

**Test Cases (including corner cases):**

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class EarthDistanceTest {

    @Test
    void testSamePoint() {
        double distance = calculateDistance(25, 35, 25, 35);
        assertEquals(0.0, distance, 0.0001);  // Expect zero distance
    }

    @Test
    void testGivenExample() {
        double distance = calculateDistance(25, 35, 35.5, 25.5);
        assertEquals(1480.0848, distance, 0.0001); // Matches the example output
    }

    @Test
    void testAntipodes() { // Points on opposite sides of the Earth
        double distance = calculateDistance(0, 0, 0, 180);
        assertEquals(20015.086, distance, 0.1 ); // Approximately half Earth's circumference
    }

    @Test
    void testNorthPoleToEquator() {
         double distance = calculateDistance(90, 0, 0, 0);  //Doesn't matter the longitude when one point is a pole
         assertEquals(10007.543, distance, 0.1 );  //Quarter Earth's circumference
    }


    @Test
    void testNearPoles() { // Check for numerical stability near poles
        double distance = calculateDistance(89.999, 0, 89.999, 180);
        assertTrue(distance < 1.0 ); // Points are very close near the pole, even with 180 longitude difference.
    }


    // Helper function to make testing easier
    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        double radius = 6371.01;
        lat1 = Math.toRadians(lat1);
        lon1 = Math.toRadians(lon1);
        lat2 = Math.toRadians(lat2);
        lon2 = Math.toRadians(lon2);
        return radius * Math.acos(Math.sin(lat1) * Math.sin(lat2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));
    }
}



```


**Key improvements and explanations of the test cases:**

* **Radian Conversion:**  The main code and the test helper function now convert latitude and longitude to radians *immediately* after reading input or setting test values. This prevents errors that could occur if the calculations were done in degrees.
* **Test Cases Cover Corner Cases:**
    * **Same Point:**  Tests if the distance between two identical points is zero.
    * **Given Example:** Verifies the provided example from the prompt.
    * **Antipodes:** Checks the distance between points on opposite sides of the globe.
    * **North Pole to Equator:** Calculates the distance from the North Pole to a point on the equator.
    * **Near Poles:** Checks if the calculation remains stable when points are very close to the poles (this is important because the `cos(latitude)` term can approach zero, which can sometimes cause numerical instability).



* **Helper Function:** The `calculateDistance` helper function makes the test code cleaner and easier to read.
* **Junit5:** The test code uses Junit5 for assertions and test structure.




Remember to add JUnit to your project if you haven't already. You can use Maven or Gradle to manage dependencies easily.  This improved code and comprehensive test suite ensures better correctness and robustness for your Earth distance calculation program.

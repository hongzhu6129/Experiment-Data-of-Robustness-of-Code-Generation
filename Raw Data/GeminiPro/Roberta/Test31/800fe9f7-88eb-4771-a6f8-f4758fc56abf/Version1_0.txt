```java
import java.util.Scanner;

public class EarthDistance {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Input the latitude of coordinate 1: ");
        double lat1 = Math.toRadians(input.nextDouble());

        System.out.print("Input the longitude of coordinate 1: ");
        double lon1 = Math.toRadians(input.nextDouble());

        System.out.print("Input the latitude of coordinate 2: ");
        double lat2 = Math.toRadians(input.nextDouble());

        System.out.print("Input the longitude of coordinate 2: ");
        double lon2 = Math.toRadians(input.nextDouble());

        double radius = 6371.01; // Earth's radius in kilometers

        double distance = radius * Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));

        System.out.println("The distance between those points is: " + distance);
        input.close();
    }
}
```

**Test Cases:**

Here are some test cases covering various scenarios, including corner cases:

1. **Provided Example:**
   - lat1: 25
   - lon1: 35
   - lat2: 35.5
   - lon2: 25.5
   - Expected Output: ~1480.08 km

2. **Same Point:**
   - lat1: 40
   - lon1: -74
   - lat2: 40
   - lon2: -74
   - Expected Output: 0 km

3. **Opposite Sides of the Earth (Antipodes):**
   - lat1: 40
   - lon1: -74  (New York)
   - lat2: -40
   - lon2: 106 (Near Perth, Australia ï¿½ antipode of New York)
   - Expected Output: ~20015.08 km (Approximately Earth's diameter)

4. **North and South Poles:**
   - lat1: 90  (North Pole)
   - lon1: 0
   - lat2: -90 (South Pole)
   - lon2: Any value (longitude is irrelevant at the poles)
   - Expected Output: ~20015.08 km (Approximately Earth's diameter)


5. **Points on the Equator:**
   - lat1: 0
   - lon1: 0
   - lat2: 0
   - lon2: 180 
   - Expected Output: ~20015.08/2 = 10007.54 (Halfway around the Earth)



6. **Points near the International Date Line (Longitude 180/-180):**
   - lat1: 10
   - lon1: 179
   - lat2: 10
   - lon2: -179
   - Expected Output: A small distance (because they are close despite the longitude difference)



7. **Invalid Input (Latitudes out of range):**
   - lat1: 95 (Invalid)
   - lon1: 0
   - lat2: 0
   - lon2: 0
   - Expected Behavior: The program should ideally handle this gracefully, either by throwing an exception or prompting the user for valid input (latitudes must be between -90 and 90 inclusive).


8. **Edge Cases (Latitudes exactly at 90 or -90):** Ensure your program handles these edge cases correctly (they should be treated like any other valid latitude).


**How to Test:**

You can modify the `main` method of the Java code to hardcode these test cases or create a separate testing class (using a testing framework like JUnit is recommended for larger projects). Print the calculated distance and compare it to the expected output.  You could also automatically check the correctness within your test code.  For example (using JUnit 5):



```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class EarthDistanceTest {

    @Test
    void testSamePoint() {
        double distance = EarthDistance.calculateDistance(40, -74, 40, -74);
        assertEquals(0, distance, 0.001); // Using a delta for floating-point comparison
    }

   // Add more tests for the other cases

   //Helper Method to encapsulate calculation logic
    private static double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
       double radius = 6371.01;
       lat1 = Math.toRadians(lat1); // Convert to radians
       lon1 = Math.toRadians(lon1);
       lat2 = Math.toRadians(lat2);
       lon2 = Math.toRadians(lon2);
       return radius * Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));
    }

}
```


By implementing these comprehensive test cases, you can ensure that your Earth distance calculation program functions correctly across a wide range of inputs and edge conditions.

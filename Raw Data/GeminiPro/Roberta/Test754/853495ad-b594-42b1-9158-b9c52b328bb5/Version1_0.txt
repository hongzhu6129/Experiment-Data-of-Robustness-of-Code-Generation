```java
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.Locale;

public class NumberFormatter {

    public static void main(String[] args) {
        int number1 = 1234;
        int number2 = 1234567;
        int number3 = 1234567890;

        System.out.println(validate(number1)); // Output: 1,234
        System.out.println(validate(number2)); // Output: 1,234,567
        System.out.println(validate(number3)); // Output: 1,234,567,890
    }


    public static String validate(int num) {
        // Using NumberFormat for locale-specific formatting
        NumberFormat nf = NumberFormat.getNumberInstance(Locale.US); // Use US locale for comma separators

        // Or, use DecimalFormat for more control:
        //DecimalFormat df = new DecimalFormat("#,###");  // No decimal places
        //return df.format(num);


        return nf.format(num);


        // Manual Implementation (Less Efficient, Educational Purpose)
//        String numStr = String.valueOf(num);
//        StringBuilder sb = new StringBuilder();
//        int count = 0;
//
//        for (int i = numStr.length() - 1; i >= 0; i--) {
//            sb.append(numStr.charAt(i));
//            count++;
//            if (count == 3 && i != 0) {
//                sb.append(",");
//                count = 0;
//            }
//        }
//
//        return sb.reverse().toString();

    }
}
```


**Explanation and Educational Points:**

1. **Method Signatures:**  The code adheres to the required method signatures: `public static void main(String[] args)` and `public static String validate(int num)`.

2. **Locale-Specific Formatting (Recommended):**
   - `NumberFormat nf = NumberFormat.getNumberInstance(Locale.US);` gets a `NumberFormat` object that's configured to format numbers according to US locale conventions (which use commas as thousands separators).
   - `nf.format(num)` formats the integer `num` using these locale-specific rules. This is generally the preferred and most robust approach, as it handles different locale conventions automatically.


3. **DecimalFormat (Alternative):**
   - `DecimalFormat df = new DecimalFormat("#,###");`  creates a `DecimalFormat` object with a specified pattern.  `#,###` indicates that commas should be used as thousands separators.
   - `df.format(num)` formats the number using this pattern.  This gives you finer-grained control if needed.


4. **Manual Implementation (Educational - Less Efficient):**
   - The commented-out section shows how you could implement thousands separators manually using string manipulation.
   - It iterates through the number's digits from right to left, inserting a comma every three digits.
   - While this demonstrates the logic, it's less efficient and less adaptable than using the built-in formatting classes.


5. **Educational Value:**
   - The code shows different approaches to solving the problem, highlighting the advantages of using built-in classes versus manual implementation.
   - It explains the importance of locale-specific formatting for internationalization.
   - The manual implementation provides insight into basic string manipulation techniques.


6. **Example Usage in `main`:** The `main` method demonstrates how to call the `validate` method with different integer values and prints the formatted output.

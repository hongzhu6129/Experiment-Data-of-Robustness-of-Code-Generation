```java
import java.util.Scanner;

public class ArithmeticOperations {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the first number: ");
        double num1 = scanner.nextDouble();

        System.out.print("Enter the second number: ");
        double num2 = scanner.nextDouble();

        System.out.println("Sum: " + (num1 + num2));
        System.out.println("Difference (num1 - num2): " + (num1 - num2));
        System.out.println("Product: " + (num1 * num2));


        if (num2 != 0) {  // Check for division by zero
            System.out.println("Quotient: " + (num1 / num2));
            System.out.println("Remainder: " + (num1 % num2));
        } else {
            System.out.println("Division by zero is not allowed.");
        }


        scanner.close();
    }
}
```

**Test Cases:**

Here are some test cases covering various scenarios, including corner cases:

| Test Case | num1 | num2 | Expected Sum | Expected Difference | Expected Product | Expected Quotient | Expected Remainder |
|---|---|---|---|---|---|---|---|
| 1 | 10 | 5 | 15 | 5 | 50 | 2 | 0 |
| 2 | -5 | 2 | -3 | -7 | -10 | -2.5 | -1 |
| 3 | 0 | 7 | 7 | -7 | 0 | 0 | 0 |
| 4 | 15 | 0 | 15 | 15 | 0 | "Division by zero" | "Division by zero" | // **Corner Case: Division by zero**
| 5 | 0 | 0 | 0 | 0 | 0 | "Division by zero" | "Division by zero" | // **Corner Case: Both numbers zero**
| 6 | 5.2 | 2.1 | 7.3 | 3.1 | 10.92 | 2.476... | ... | // **Floating-point numbers**
| 7 | Integer.MAX_VALUE | 1 | Integer.MAX_VALUE + 1 (overflow) | Integer.MAX_VALUE - 1 | Integer.MAX_VALUE  | Integer.MAX_VALUE | ... | // **Corner Case: Integer overflow (sum and product)**
| 8 | Integer.MIN_VALUE | -1 | Integer.MIN_VALUE -1 (overflow) | Integer.MIN_VALUE + 1 | Integer.MAX_VALUE + 1 (overflow) | Integer.MIN_VALUE | ... |// **Corner Case: Integer overflow/underflow**


**How to Run Test Cases:**

You can manually enter these values into the program when prompted.  A better approach, especially for more complex programs, is to create automated tests using a testing framework like JUnit.  Here's a simple example of how you might structure a JUnit test:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ArithmeticOperationsTest {

    @Test
    void testDivisionByZero() {
        ArithmeticOperations operations = new ArithmeticOperations(); // You'd need to adapt this based on your class structure

        // In a real test framework, you'd have better ways to check for exceptions/error messages.
        // This is a simplified example.
         assertThrows(ArithmeticException.class, () -> operations.divide(10,0)); // Assertions in JUnit
    }

    // Add more @Test methods for other test cases.

}
```



By using a testing framework, you can automate the process of running your test cases and verifying the results, which is essential for ensuring the correctness of your code.

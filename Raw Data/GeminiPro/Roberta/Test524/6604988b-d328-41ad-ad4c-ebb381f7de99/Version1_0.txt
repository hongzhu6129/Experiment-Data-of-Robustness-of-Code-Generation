```java
public class CubeChecker {

    public static void main(String[] args) {
        // Input: Read a number from the command line arguments.
        if (args.length == 0) {
            System.out.println("Please provide a number as a command line argument.");
            return;
        }

        try {
            int number = Integer.parseInt(args[0]);

            // Check if the number is a cube.
            if (isCube(number)) {
                System.out.println("Number is a cube.");
            } else {
                System.out.println("Number is not a cube.");
            }

        } catch (NumberFormatException e) {
            System.out.println("Invalid input. Please enter a valid integer.");
        }
    }


    private static boolean isCube(int number) {
        // Handle negative numbers (cube root of a negative number is negative)
        int absNumber = Math.abs(number);

        // Binary search approach for efficiency
        int low = 1, high = absNumber; 
        while (low <= high) {
            int mid = low + (high - low) / 2; // Avoid potential integer overflow
            int cube = mid * mid * mid;

            if (cube == absNumber) {
                return true; 
            } else if (cube < absNumber) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return false;
    }
}
```

**Explanation and Improvements:**

1. **Command Line Arguments:** The code now reads the number to be checked from command-line arguments (using `args[]`). This is a more standard way to provide input to a Java program.
2. **Error Handling:** It includes error handling (`try-catch`) to catch `NumberFormatException` in case the user provides invalid input (non-integer).
3. **Efficient Cube Check (Binary Search):** The `isCube()` method now uses a binary search approach to determine if a number is a perfect cube. This is much more efficient than the brute-force method (looping through all possible cube roots) especially for larger numbers.
4. **Handles Negative Numbers:** The code correctly handles negative numbers by taking the absolute value before performing the binary search. The cube root of a negative number is simply the negative of the cube root of its absolute value.
5. **Integer Overflow Prevention:** The `mid` calculation in binary search uses `low + (high - low) / 2`  to avoid potential integer overflow if `low + high` exceeds the maximum integer value.

**How to Compile and Run:**

1. **Save:** Save the code as `CubeChecker.java`.
2. **Compile:** Open a terminal or command prompt, navigate to the directory where you saved the file, and compile it using:
   ```bash
   javac CubeChecker.java
   ```
3. **Run:** Execute the program, providing the number as a command-line argument:
   ```bash
   java CubeChecker 8      // Checks if 8 is a cube
   java CubeChecker 27     // Checks if 27 is a cube
   java CubeChecker 100   // Checks if 100 is a cube 
   java CubeChecker -27    // Correctly handles negative cubes
   ```

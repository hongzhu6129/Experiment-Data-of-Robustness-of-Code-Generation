```java
import java.util.Scanner;

public class NNN {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.print("Enter an integer (n): ");

        try {
            int n = input.nextInt();

            // Handle negative input (optional, depends on requirements)
            if (n < 0) {
                System.out.println("Input must be a non-negative integer.");
                return;
            }

            int nn = n * 10 + n;
            int nnn = n * 100 + nn;
            int result = n + nn + nnn;

            System.out.println("Result: " + result);


        } catch (java.util.InputMismatchException e) {
            System.out.println("Invalid input. Please enter an integer.");
        } finally {
            input.close(); // Close the scanner to prevent resource leaks
        }
    }
}
```


**Test Cases:**

| Input (n) | Expected Output | Explanation                                           |
| --------- | --------------- | ----------------------------------------------------- |
| 0         | 0               | 0 + 00 + 000 = 0                                     |
| 1         | 123             | 1 + 11 + 111 = 123                                    |
| 5         | 615             | 5 + 55 + 555 = 615                                    |
| 9         | 1107            | 9 + 99 + 999 = 1107                                   |
| -2      | "Input must be..." | Handling negative input (if implemented this way)      |
| 10       | 1210           | 10+1010 (incorrect, designed for single-digit input) |
| a         | "Invalid input..."| Handling non-integer input                           |
| 2147483647 (Integer.MAX_VALUE)| Overflow handled differently depending on how you calculate `nn` and `nnn`.  It's safer to convert to `long` before the calculations if large inputs are expected. |



**Improvements in the Code:**

* **Error Handling:** The code now includes a `try-catch` block to handle potential `InputMismatchException` if the user enters non-integer input. This makes the program more robust.
* **Resource Management:** The `Scanner` is closed in a `finally` block to ensure that the resource is released even if an exception occurs.
* **Clarity and Comments:** Comments have been added to explain the logic, and the variable names are more descriptive (e.g., `result` instead of `sum`).
* **Optional Negative Input Handling:**  The code demonstrates how to handle negative inputs, although the requirements for negative numbers are not explicitly stated in your initial prompt. You can remove that check if negative numbers are valid inputs in your use case.


**Important Note about Large Inputs and Overflow:**

The original calculation using `n * 10 + n` and  `n * 100 + nn`  can lead to integer overflow if `n` is large.  If you need to handle potentially large inputs, consider doing the calculations using `long` data type to avoid overflow issues.  For example:


```java
long ln = n; // Convert to long
long nn = ln * 10 + ln;
long nnn = ln * 100 + nn;
long result = ln + nn + nnn;
System.out.println("Result: " + result);
```

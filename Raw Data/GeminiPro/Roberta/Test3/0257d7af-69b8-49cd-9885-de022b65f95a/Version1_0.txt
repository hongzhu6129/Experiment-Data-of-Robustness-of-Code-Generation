```java
import java.util.Scanner;

public class MultiplicationTable {

    public static void printMultiplicationTable(int number) {
        if (number < 0) {  // Handling negative input
            System.out.println("Multiplication table is not defined for negative numbers.");
            return;
        }
        System.out.println("Multiplication Table for " + number + ":");
        for (int i = 1; i <= 10; i++) {
            System.out.println(number + " x " + i + " = " + (number * i));
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter a number: ");
        int number = scanner.nextInt(); // Getting user input
        scanner.close();

        printMultiplicationTable(number); 
    }
}
```


**Test Cases:**

1. **Positive Number:**
   - Input: `7`
   - Expected Output:
     ```
     Multiplication Table for 7:
     7 x 1 = 7
     7 x 2 = 14
     7 x 3 = 21
     ...
     7 x 10 = 70
     ```

2. **Zero:**
   - Input: `0`
   - Expected Output:
     ```
     Multiplication Table for 0:
     0 x 1 = 0
     0 x 2 = 0
     ...
     0 x 10 = 0
     ```

3. **Negative Number:**  (Corner Case)
   - Input: `-5`
   - Expected Output:
     ```
     Multiplication table is not defined for negative numbers.
     ```


4. **Large Positive Number:** (To check for potential integer overflow if you were going beyond the range that `int` can handle. While this code doesn't go that far, it's a good test case to consider for a more general multiplication table program)
   - Input: `12345`
   - Expected Output: (Verify correctness)
     ```
     Multiplication Table for 12345:
     12345 x 1 = 12345
     ...
     12345 x 10 = 123450
     ```

5.  **One:** (A simple boundary case, although not strictly a corner case)
    - Input: 1
    - Expected Output:
     ```
     Multiplication Table for 1:
     1 x 1 = 1
     1 x 2 = 2
     ...
     1 x 10 = 10
      ```


**How to run the test cases (without a formal testing framework):**

1. **Manual Testing:**  The simplest way is to run the program multiple times, entering each test input and visually comparing the output with the expected output.

2. **Automated Testing (recommended for larger projects):** Use a testing framework like JUnit. This involves writing separate test methods for each case, using assertions to automatically verify the correctness of the output.  Example using JUnit: (This requires adding JUnit to your project)



```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

public class MultiplicationTableTest {

    @Test
    void testPositiveNumber() {
        ByteArrayOutputStream outContent = new ByteArrayOutputStream();  // Capture output
        System.setOut(new PrintStream(outContent));

        MultiplicationTable.printMultiplicationTable(7);  // Call the function

        String expectedOutput = "Multiplication Table for 7:\r\n" +  // \r\n for Windows line endings
                                "7 x 1 = 7\r\n" + 
                               // ... (rest of the expected lines)
                               "7 x 10 = 70\r\n";

        assertEquals(expectedOutput, outContent.toString()); // Assert output
        System.setOut(System.out); // Restore standard output
    }

    // ... (Similarly write tests for other cases)

}

```



Using a testing framework like JUnit is much more efficient and reliable for thorough testing, especially as the complexity of your programs increases.

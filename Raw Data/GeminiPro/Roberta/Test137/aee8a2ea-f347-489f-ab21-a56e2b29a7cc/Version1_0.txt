```java
import java.util.HashMap;
import java.util.Map;

public class SingleNumberFinder {

    public static void main(String[] args) {
        int[] nums1 = {2, 2, 1};
        int single1 = getSingleNumber(nums1);
        System.out.println("Single number in nums1: " + single1); // Output: 1

        int[] nums2 = {4, 1, 2, 1, 2};
        int single2 = getSingleNumber(nums2);
        System.out.println("Single number in nums2: " + single2); // Output: 4

        int[] nums3 = {1};
        int single3 = getSingleNumber(nums3);
        System.out.println("Single number in nums3: " + single3); // Output: 1


         int[] emptyArray = {}; //Illustrate empty array case
        int singleEmpty = getSingleNumber(emptyArray);
        System.out.println("Single number in empty array : " + singleEmpty); // Output: 0



    }

    public static int getSingleNumber(int[] nums) {
        // Educational approach using a HashMap
        if (nums == null || nums.length == 0) { // Handle null or empty input
            return 0; // Or throw an exception, depending on the desired behavior
        }


        Map<Integer, Integer> countMap = new HashMap<>();

        // 1. Count occurrences of each number
        for (int num : nums) {
            countMap.put(num, countMap.getOrDefault(num, 0) + 1);
            /*
             * getOrDefault is used to retrieve the current count of the number 'num' from the map.
             * If the number is not present in the map (first encounter), it defaults to 0.
             * We then increment this count by 1 and put it back into the map.
             */
        }

        // 2. Find the number with a count of 1
        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {
            if (entry.getValue() == 1) {
                return entry.getKey();
            }
        }

        // Should not reach here if the problem statement guarantees a single number appearing once.
        return 0; // Or throw an exception
    }


}
```


Explanation and Improvements:

1. HashMap Approach:  This code uses a `HashMap` to store the frequency of each number in the array.  This is a clear and educational approach as it demonstrates a fundamental data structure.

2. Handles Edge Cases: I've added a check at the beginning of `getSingleNumber` to handle `null` or empty input arrays. This makes the code more robust. You can choose to return 0 or throw an exception as needed.  Illustrative examples are in `main`.

3.  Clear Comments: The code is well-commented to explain the logic, especially the use of `getOrDefault`.

4. Efficient Return:  Once the number with a count of 1 is found, the function immediately returns it, avoiding unnecessary iterations.

5. Educational Value:  This approach focuses on clarity and understanding the steps involved, making it suitable for an educational context.  It avoids more complex (though potentially more performant in terms of Big O) solutions like bitwise XOR, which might be confusing for beginners.


Why this is a good educational solution:

* Demonstrates use of HashMap: This introduces a key data structure for storing and retrieving data based on keys.
* Step-by-step logic: The code follows a logical flow: count occurrences, then find the number with count 1.  This makes it easy to follow and understand.
* Handles edge cases: Robustness with null or empty input is important to show good practice.
* Clear and concise:  The code is well-formatted and not overly complex, making it easy to read and learn from.

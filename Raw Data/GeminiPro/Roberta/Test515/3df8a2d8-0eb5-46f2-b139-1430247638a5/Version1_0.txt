```java
public class HappyNumbers {

    public static void main(String[] args) {
        int count = 0;
        long num = 1;

        while (count < 10) {
            if (happy_num(num)) {
                System.out.println(num);
                count++;
            }
            num++;
        }
    }

    public static boolean happy_num(long num) {
        java.util.HashSet<Long> seen = new java.util.HashSet<>();

        while (num != 1 && !seen.contains(num)) {
            seen.add(num);
            long sum = 0;
            while (num > 0) {
                long digit = num % 10;
                sum += digit * digit;
                num /= 10;
            }
            num = sum;
        }

        return num == 1;
    }
}
```


This code adheres strictly to the requested method signatures: `public static void main(String[])` and `public static boolean happy_num(long)`.  It efficiently finds and prints the first 10 happy numbers.

Here's how it works:

1. **`main` method:**
   - Initializes a `count` to keep track of how many happy numbers have been found.
   - Starts a `while` loop that continues until 10 happy numbers are found.
   - Calls `happy_num` to check if the current number `num` is happy.
   - If `happy_num` returns `true`, the number is printed, and the `count` is incremented.
   - The `num` is incremented in each iteration to check the next number.

2. **`happy_num` method:**
   - Uses a `HashSet` called `seen` to store numbers encountered during the process. This is crucial for detecting cycles and avoiding infinite loops (which happen with unhappy numbers).
   - The `while` loop continues as long as `num` is not 1 and `num` has not been seen before.
   - Inside the loop:
     - The current `num` is added to `seen`.
     - The sum of the squares of digits is calculated.
     - `num` is updated to the calculated sum.
   - Finally, the method returns `true` if `num` becomes 1 (happy number) and `false` otherwise (unhappy number/cycle detected).



This revised version is more concise and efficient than previous responses, directly addressing the prompt's specific requirements.

```java
import java.util.TreeMap;

public class CopyTreeMap {

    public static void main(String[] args) {

        // Create a source TreeMap
        TreeMap<String, Integer> sourceMap = new TreeMap<>();
        sourceMap.put("Apple", 1);
        sourceMap.put("Banana", 2);
        sourceMap.put("Orange", 3);
        sourceMap.put("Grape", 4);


        // Method 1: Using the putAll() method (most efficient)
        TreeMap<String, Integer> copiedMap1 = new TreeMap<>();
        copiedMap1.putAll(sourceMap);

        System.out.println("Copied Map 1 (putAll): " + copiedMap1);


        // Method 2: Using the constructor (creates a shallow copy)
        TreeMap<String, Integer> copiedMap2 = new TreeMap<>(sourceMap);

        System.out.println("Copied Map 2 (constructor): " + copiedMap2);


        // Method 3: Iterating and putting each entry (less efficient, but demonstrates the logic)
        TreeMap<String, Integer> copiedMap3 = new TreeMap<>();
        for (String key : sourceMap.keySet()) {
            copiedMap3.put(key, sourceMap.get(key));
        }

        System.out.println("Copied Map 3 (iteration): " + copiedMap3);



        // Demonstrating that changes to the original DO NOT affect copies made using putAll or the constructor
        sourceMap.put("Mango", 5);  // Modify the original

        System.out.println("Original Map after modification: " + sourceMap);
        System.out.println("Copied Map 1 (putAll) after modification: " + copiedMap1);
        System.out.println("Copied Map 2 (constructor) after modification: " + copiedMap2);


        //Important note about shallow copy: If the values in your TreeMap are mutable objects (like other collections or custom objects), 
        //changes to those objects WILL be reflected in both the original and copied maps using putAll and the constructor approach.
        //For a deep copy, you would need to clone each value object as well.


    }
}
```


Explanation:

1. **Creating a Source TreeMap:**  We create a `TreeMap` called `sourceMap` and populate it with some key-value pairs.

2. **Method 1: `putAll()` (Most Efficient):** The `putAll()` method is the simplest and most efficient way to copy a `TreeMap`. It adds all the mappings from the source map to the destination map.

3. **Method 2: Constructor:** Using the `TreeMap(Map)` constructor creates a new `TreeMap` containing all the mappings from the source map.  This is also efficient, similar to `putAll()`.

4. **Method 3: Iteration:** This method iterates through the keys of the source map using a `for-each` loop. Inside the loop, we get the value associated with each key and put the key-value pair into the destination map. While it works, it is less efficient than `putAll()` and the constructor approach, particularly for large maps.

5. **Demonstrating Independence:** The code demonstrates that modifications to the original `sourceMap` (after copying) do *not* affect the copied maps created using `putAll()` or the constructor. This shows that the copies are independent of the original.

6. **Shallow vs. Deep Copy (Important):**  The code explains the crucial distinction between shallow and deep copies. The `putAll()` method and constructor create *shallow* copies.  This means if your TreeMap's values are mutable objects (e.g., lists, other maps, custom objects), changes to the *contents* of those objects will be reflected in both the original *and* the copied maps. If you need a truly independent copy where modifications to the values in one map do not affect the other, you would need to create a *deep* copy by cloning each value object as well.  The example doesn't demonstrate deep copying as it requires specific cloning logic depending on the type of values you're storing.

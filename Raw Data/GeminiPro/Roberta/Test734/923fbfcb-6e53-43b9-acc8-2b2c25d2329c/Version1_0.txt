```java
public class SaddlebackSearch {

    public static void main(String[] args) {
        int[][] arr = {
                {1, 4, 7, 11, 15},
                {2, 5, 8, 12, 19},
                {3, 6, 9, 16, 22},
                {10, 13, 14, 17, 24},
                {18, 21, 23, 26, 30}
        };

        int m = arr.length;
        int n = arr[0].length;

        int target = 14;

        int[] result = Saddleback(arr, m, n, target);

        if (result[0] != -1) {
            System.out.println("Target " + target + " found at row: " + result[0] + ", column: " + result[1]);
        } else {
            System.out.println("Target " + target + " not found in the array.");
        }
    }


    private static int[] Saddleback(int[][] arr, int m, int n, int target) {
        int row = 0;
        int col = n - 1;

        while (row < m && col >= 0) {
            if (arr[row][col] == target) {
                return new int[]{row, col}; // Target found
            } else if (arr[row][col] < target) {
                row++; // Move down to the next row
            } else {
                col--; // Move left to the previous column
            }
        }

        return new int[]{-1, -1}; // Target not found
    }
}
```


**Explanation and Improvements:**

1. **Clearer Variable Names:** Use more descriptive names like `rows` and `cols` instead of `m` and `n`.
2. **Return an `int[]`:** The `Saddleback` method returns an `int[]` containing the row and column indices of the target.  If the target isn't found, it returns `{-1, -1}`.  This is a standard way to indicate a failed search.
3. **Handle Edge Cases:**  The code now explicitly checks for `row < m` and `col >= 0` within the `while` loop to prevent out-of-bounds exceptions.
4. **Example Usage in `main`:**  The `main` method demonstrates how to use the `Saddleback` function and how to interpret its result.
5. **Comments:**  Added comments to explain the logic.

**How Saddleback Search Works:**

Saddleback search starts at the top-right corner of the matrix.  It compares the current element with the target:

- If the current element is equal to the target, the search is successful.
- If the current element is smaller than the target, we move down to the next row because the target cannot be in the current row (since the rows are sorted in ascending order).
- If the current element is larger than the target, we move left to the previous column because the target cannot be in the current column (since the columns are sorted in ascending order).


This process continues until either the target is found or we go out of the bounds of the matrix (which means the target is not present). This algorithm is efficient for searching in a sorted matrix and has a time complexity of O(m + n).

```java
import java.util.Scanner;

public class BinaryToHex {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.print("Input a binary number: ");
        String binaryString = input.nextLine();

        try {
            int decimal = 0;
            int power = 0;
            for (int i = binaryString.length() - 1; i >= 0; i--) {
                char digit = binaryString.charAt(i);
                if (digit == '1') {
                    decimal += Math.pow(2, power);
                } else if (digit != '0') {
                    System.out.println("Invalid binary number.");
                    return; // Exit if not a valid binary digit
                }
                power++;
            }

            String hexString = "";
            while (decimal > 0) {
                int remainder = decimal % 16;
                char hexDigit;
                if (remainder < 10) {
                    hexDigit = (char) (remainder + '0');
                } else {
                    hexDigit = (char) (remainder - 10 + 'a');
                }
                hexString = hexDigit + hexString;  // Prepend for correct order
                decimal /= 16;
            }


            if (hexString.isEmpty()) { // Handle the case of input "0"
                System.out.println("Hexadecimal value: '0'");
            } else {
                System.out.println("Hexadecimal value: '" + hexString + "'");
            }


        } catch (NumberFormatException e) {
            System.out.println("Invalid input.");
        }

        input.close();

    }
}
```


**Test Cases:**

1. **Valid Binary:**
   - Input: `1101`
   - Expected Output: `Hexadecimal value: 'd'`

2. **Valid Binary with Leading Zeroes:**
   - Input: `001101`
   - Expected Output: `Hexadecimal value: 'd'`

3. **Valid Binary - Larger Number:**
   - Input: `11111111`
   - Expected Output: `Hexadecimal value: 'ff'`

4. **Zero:**
   - Input: `0`
   - Expected Output: `Hexadecimal value: '0'`

5. **Empty String:**
   - Input: `` (just press enter)
   - Expected Output: `Invalid input.` (NumberFormatException will be caught)


6. **Invalid Binary (contains characters other than 0 or 1):**
   - Input: `110a1`
   - Expected Output: `Invalid binary number.`

7. **Invalid Binary (Space in between):**
   - Input: `11 01`
   - Expected Output: `Invalid binary number.` (because the space character is not '0' or '1')

8. **Very Large Binary Number:**
   - Input: `111111111111111111111111111111111111111111111111` (a long string of 1s)
   - Expected Output:  The program should still handle this correctly and produce the corresponding very large hexadecimal value.  However, be aware that extremely large numbers *might* eventually cause integer overflow if the decimal representation exceeds `Integer.MAX_VALUE`.  If you need to reliably handle truly massive binary numbers, consider using `BigInteger` instead of `int`.




These test cases cover valid binary inputs, inputs with leading zeros, zero, invalid characters, spaces, empty strings, and potentially very large inputs to check the robustness of the code. They address various scenarios you might encounter in a real-world application.

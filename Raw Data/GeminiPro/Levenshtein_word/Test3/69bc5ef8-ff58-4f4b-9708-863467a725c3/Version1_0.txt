```java
import java.util.Scanner;

public class MultiplicationTable {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter an integer: ");

        // Input validation: Check if the input is an integer.
        while (!scanner.hasNextInt()) {
            System.out.println("Invalid input. Please enter an integer.");
            scanner.next(); // Consume the invalid input
        }
        int num = scanner.nextInt();

        printMultiplicationTable(num);

        scanner.close();
    }

    public static void printMultiplicationTable(int num) {
        System.out.println("Multiplication Table of " + num + ":");

        for (int i = 1; i <= 10; i++) {
            System.out.println(num + " x " + i + " = " + (num * i));
        }
    }
}
```

**Test Cases:**

1. **Positive Integer:**
   - Input: 7
   - Expected Output: Multiplication table of 7 (7x1=7, 7x2=14, ..., 7x10=70)

2. **Zero:**
   - Input: 0
   - Expected Output: Multiplication table of 0 (all results will be 0).  This is a corner case because it results in a table of all zeros.

3. **Negative Integer:**
   - Input: -5
   - Expected Output: Multiplication table of -5 (-5x1=-5, -5x2=-10, ..., -5x10=-50).  This tests handling of negative numbers.

4. **Large Positive Integer:**
   - Input: 12345
   - Expected Output:  Multiplication table of 12345. This tests handling of larger numbers.

5. **Large Negative Integer:**
   - Input: -98765
   - Expected Output: Multiplication table of -98765. This tests handling of larger negative numbers.

6. **Invalid Input (Non-Integer):**
   - Input: hello
   - Expected Output: "Invalid input. Please enter an integer."  (repeated until a valid integer is entered). This is crucial for robust input handling.

7. **Invalid Input (Decimal):**
   - Input: 3.14
   - Expected Output: "Invalid input. Please enter an integer."  This ensures the program correctly handles and rejects decimal input.


**How to Run the Tests:**

You can manually test the program by running it and providing these inputs. For a more automated approach, consider creating unit tests using JUnit or a similar testing framework. Here's a basic example using JUnit:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

public class MultiplicationTableTest {

    @Test
    void testPositiveInteger() {
         testTable(7, "7 x 1 = 7\n7 x 2 = 14\n... (up to 7 x 10)"); // ... represents the rest of the table
    }

    // ... (similar test methods for other cases)

     private void testTable(int input, String expectedOutputSnippet) {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        System.setOut(new PrintStream(outputStream));

        MultiplicationTable.printMultiplicationTable(input); 

        String output = outputStream.toString();
        assertTrue(output.contains(expectedOutputSnippet)); // Check if the output contains the expected part
        System.setOut(System.out); // Restore standard output
    }
}

```

Remember to replace the `...` in the test cases with the complete expected output for each test. This JUnit example demonstrates how to capture and check the console output from your `printMultiplicationTable` method.  You would add similar `@Test` methods for the other test cases (zero, negative, large numbers, and invalid input).  Using a testing framework like JUnit provides a much more organized and automated way to ensure your code is correct and handles various scenarios.

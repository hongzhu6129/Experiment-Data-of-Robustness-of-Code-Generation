```java
import java.util.Scanner;

public class CircleCalculations {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Enter the radius of the circle in kilometers: ");
        double radius = input.nextDouble();

        // Calculate the perimeter (circumference)
        double perimeter = 2 * Math.PI * radius;

        // Calculate the area
        double area = Math.PI * radius * radius;

        System.out.println("Perimeter is = " + perimeter);
        System.out.println("Area is = " + area);

        input.close(); 
    }
}
```

**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

| Test Case | Radius (km) | Expected Perimeter (km) | Expected Area (km�) | Notes                                 |
| --------- | ----------- | ------------------------ | ------------------- | ------------------------------------ |
| 1        | 7.5         | 47.1238898...           | 176.7145867...       | Example from the prompt               |
| 2        | 0           | 0                       | 0                   | Zero radius (corner case)            |
| 3        | 1           | 6.2831853...           | 3.1415926...       | Unit radius                         |
| 4        | 10          | 62.831853...           | 314.15926...       | Larger radius                       |
| 5        | 0.5         | 3.1415926...           | 0.7853981...       | Smaller radius                       |
| 6        | -1          | Error                    | Error                 | Invalid input (negative radius) Should handle gracefully, e.g., print an error message. |
| 7        | Double.MAX_VALUE| Infinity or Error        | Infinity or Error      | Extremely large value (corner case). Might overflow depending on how Java handles `Double.MAX_VALUE` in these calculations. Expect an extremely large number or an error/exception.      |



**How to Run the Test Cases:**

1. **Manual Testing:** You can run the program multiple times, entering each radius value from the test cases.  Compare the output with the expected values.

2. **Automated Testing (Recommended):**  For more robust testing, especially with many test cases, use JUnit or another testing framework.  Here�s a basic JUnit example:

   ```java
   import org.junit.jupiter.api.Test;
   import static org.junit.jupiter.api.Assertions.*;

   public class CircleCalculationsTest {

       @Test
       void testCalculatePerimeter() {
           CircleCalculations calculator = new CircleCalculations(); // You might need to adapt this if your methods aren't static.
           assertEquals(0, calculator.calculatePerimeter(0), 0.0001); // Delta for floating-point comparison
           assertEquals(6.2831853, calculator.calculatePerimeter(1), 0.0001);
           // Add more assertions for other test cases...
       }
    //Similar Tests for area and error handling
       @Test
       void testInvalidRadius(){
           CircleCalculations calculator = new CircleCalculations();
           assertThrows(IllegalArgumentException.class, () -> calculator.calculateArea(-1));
           assertThrows(IllegalArgumentException.class, () -> calculator.calculatePerimeter(-1));
           // Check that the correct exceptions are thrown
       }
   }

   ```

This JUnit example demonstrates how to create test methods to verify the `calculatePerimeter` (you would also create a `calculateArea` method and test it similarly).  The `assertEquals` method checks if the calculated value is within a small delta (tolerance) of the expected value, which is essential when comparing floating-point numbers. The `testInvalidRadius` tests the case where a negative radius is given as input, verifying if an `IllegalArgumentException` is thrown. Adapt the test cases and expected exceptions to match your exact error handling implementation.


By running these tests (in an IDE or using a build tool), you can ensure that your program behaves correctly under different conditions and quickly identify and fix any issues.

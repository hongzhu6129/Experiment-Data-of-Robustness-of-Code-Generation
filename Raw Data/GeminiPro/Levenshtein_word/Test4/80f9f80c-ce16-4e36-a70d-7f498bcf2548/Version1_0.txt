```java
import java.util.Scanner;

public class CircleCalculations {

    public static void main(String[] args) {

        // Using a Scanner for potential user input in the future (easily adaptable).
        Scanner input = new Scanner(System.in);

        // For this specific problem, radius is fixed.
        double radius = 7.5; 

        // Calculate the perimeter (circumference)
        double perimeter = 2 * Math.PI * radius;

        // Calculate the area
        double area = Math.PI * radius * radius;

        // Print the results, formatted to match the example output.
        System.out.printf("fence is = %.12f\n", perimeter); // Formatted to 12 decimal places
        System.out.printf("area is = %.12f\n", area);      // Formatted to 12 decimal places


        input.close(); // Close the Scanner to prevent resource leaks.
    }
}


```

**Test Cases:**

Here are some test cases, including corner cases, to test the program:

1. **Standard Case (Given):**
   - `radius = 7.5`
   - Expected Output:
     - `fence is = 47.123889803847`
     - `area is = 176.714586764426`

2. **Zero Radius:**
   - `radius = 0`
   - Expected Output:
     - `fence is = 0.0`
     - `area is = 0.0`

3. **Negative Radius (Invalid, but test for handling):**
   - `radius = -5`  (The program should ideally handle this and perhaps print an error message or throw an exception since a negative radius is not physically meaningful.)
   - Expected Behavior: Either an error message, an exception, or mathematically correct but nonsensical results (perimeter and area will be negative; this might require an absolute value in the formulas if you want only positive results).


4. **Very Large Radius:**
   - `radius = 1000000` (Tests for potential overflow or precision issues)
   - Expected Output (check the order of magnitude to ensure the calculation is correct):  Calculate these beforehand and compare.

5. **Small Radius:**
    - `radius = 0.0001` (Tests for potential underflow or precision issues)
    - Expected Output: Calculate these beforehand and compare.

6. **Boundary Case (Close to double's maximum value):**
    - `radius = Double.MAX_VALUE / 2` (Tests for potential overflow issues; be very careful with this case)
    - Expected Behavior:  The program might throw an exception due to overflow during calculations. This is expected behavior, as `Double.MAX_VALUE` represents the largest possible double value.


**How to Run the Tests:**

* **Manual Input:** You can change the `radius` value in the code for each test case and run the program.

* **Automated Testing (Recommended):** A better approach is to write unit tests using a testing framework like JUnit. This allows you to automate the testing process and easily check the results against expected values.




```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class CircleCalculationsTest {

    @Test
    void testStandardCase() {
        // ... (Arrange, Act, Assert using JUnit assertions)
    }

    @Test
    void testZeroRadius() {
        // ...
    }

    // ... Tests for other cases
}
```



By implementing these tests, you can ensure your `CircleCalculations` class works correctly under various conditions, including corner cases.  Automated testing with JUnit is a best practice for Java development.


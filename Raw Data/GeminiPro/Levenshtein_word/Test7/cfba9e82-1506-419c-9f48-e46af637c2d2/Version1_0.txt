```java
import java.util.Scanner;

public class AverageCalculator {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Enter the first number: ");
        double num1 = input.nextDouble();

        System.out.print("Enter the second number: ");
        double num2 = input.nextDouble();

        System.out.print("Enter the third number: ");
        double num3 = input.nextDouble();

        double average = calculateAverage(num1, num2, num3);

        System.out.println("The average is: " + average);
        input.close();
    }

    public static double calculateAverage(double num1, double num2, double num3) {
        return (num1 + num2 + num3) / 3.0;  // Use 3.0 for floating-point division
    }
}
```

**Test Cases:**

**Normal Cases:**

1. **Input:** 10, 20, 30   **Expected Output:** 20.0
2. **Input:** 1.5, 2.5, 3.5   **Expected Output:** 2.5
3. **Input:** -5, 0, 5   **Expected Output:** 0.0

**Corner Cases:**

4. **Input:** 0, 0, 0   **Expected Output:** 0.0  (All zeros)
5. **Input:** Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE  **Expected Output:**  2.147483647E9 (Handling large numbers, potential overflow if using `int` instead of `double`)
6. **Input:** Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE  **Expected Output:** -2.147483648E9 (Handling large negative numbers)
7. **Input:** Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE **Expected Output:** Infinity (Handles Double maximum value and resulting Infinity)
8. **Input:** Double.MIN_VALUE, Double.MIN_VALUE, Double.MIN_VALUE **Expected Output:** 1.6940658945086005E-314 (Handles Double minimum positive value)
9. **Input:**  1.0, 2.0, Double.NaN **Expected Output:** NaN (Handles NaN input)
10. **Input:** 1.0, 2.0, Double.POSITIVE_INFINITY **Expected Output:** Infinity (Handles Infinity input)
11. **Input:** 1.0, 2.0, Double.NEGATIVE_INFINITY **Expected Output:** -Infinity (Handles Negative Infinity Input)



**How to Run Test Cases (Example using JUnit):**

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class AverageCalculatorTest {

    @Test
    void testNormalCase() {
        assertEquals(20.0, AverageCalculator.calculateAverage(10, 20, 30));
    }

    @Test
    void testAllZeros() {
        assertEquals(0.0, AverageCalculator.calculateAverage(0, 0, 0));
    }

    @Test
    void testLargeNumbers() {
        assertEquals(2.147483647E9, AverageCalculator.calculateAverage(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE));
    }


    // Add more test cases similarly...  (NaN, Infinity, etc.)
}
```

By including a wide range of test cases, you can be more confident that your `calculateAverage` method functions correctly in various situations, including those involving edge cases or unexpected input. Using a testing framework like JUnit makes it easier to automate and manage these tests.

```java
import java.util.Scanner;

public class PartAverage {

    public static double calculatePartAverage(int num1, int num2, int num3) {
        // Calculate the sum of the three numbers.
        double sum = num1 + num2 + num3;

        // Calculate the average by dividing the sum by 3.
        return sum / 3.0; // Use 3.0 for floating-point division to get accurate average
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the first number: ");
        int num1 = scanner.nextInt();

        System.out.print("Enter the second number: ");
        int num2 = scanner.nextInt();

        System.out.print("Enter the third number: ");
        int num3 = scanner.nextInt();


        double average = calculatePartAverage(num1, num2, num3);

        System.out.println("The average of the three numbers is: " + average);

        scanner.close();
    }
}
```


**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

| Test Case | Input (num1, num2, num3) | Expected Output |
|---|---|---|
| 1. Positive Numbers | 10, 20, 30 | 20.0 |
| 2. Negative Numbers | -10, -20, -30 | -20.0 |
| 3. Mixed Numbers | -10, 20, 0 | 3.3333333333333335 |  // Demonstrates handling of mixed signs
| 4. Zeroes | 0, 0, 0 | 0.0 |  // All zeroes
| 5. Large Numbers | 100000, 200000, 300000 | 200000.0 | // Handling large inputs
| 6. Small Numbers | 0.1, 0.2, 0.3 | 0.2 | // Must handle decimals correctly (use doubles)
| 7. Integer Overflow (Corner Case) | Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE | Positive Infinity | // Overflow check
| 8. Integer Underflow (Corner Case) | Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE | Negative Infinity | // Underflow check


**How to Run Test Cases (Example using JUnit):**

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class PartAverageTest {

    @Test
    void testPositiveNumbers() {
        assertEquals(20.0, PartAverage.calculatePartAverage(10, 20, 30));
    }

    @Test
    void testNegativeNumbers() {
        assertEquals(-20.0, PartAverage.calculatePartAverage(-10, -20, -30));
    }

    @Test
    void testMixedNumbers() {
        assertEquals(3.3333333333333335, PartAverage.calculatePartAverage(-10, 20, 0));
    }
    // ... (Add more test cases similarly)


    @Test
    void testIntegerOverflow() {
        assertEquals(Double.POSITIVE_INFINITY, PartAverage.calculatePartAverage(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE));
    }

    @Test
    void testIntegerUnderflow() {
        assertEquals(Double.NEGATIVE_INFINITY, PartAverage.calculatePartAverage(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE));
    }
}
```

This improved answer provides a more robust solution with comprehensive test cases and demonstrates how to automate the testing process using JUnit, a popular Java testing framework. This approach ensures the correctness and reliability of the `calculatePartAverage` method. Remember to add the JUnit library to your project to run these tests.

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class NumberComparator {

    /**
     * Compares two numbers and returns an integer indicating their relationship.
     *
     * @param num1 The first number.
     * @param num2 The second number.
     * @return -1 if num1 is less than num2, 0 if they are equal, and 1 if num1 is greater than num2.
     */
    public int compare(double num1, double num2) {
        if (num1 < num2) {
            return -1;
        } else if (num1 == num2) {
            return 0;
        } else {
            return 1;
        }
    }

    // Test cases using JUnit 5
    public static class NumberComparatorTest {

        @Test
        void testLessThan() {
            NumberComparator comparator = new NumberComparator();
            assertEquals(-1, comparator.compare(1, 2));
            assertEquals(-1, comparator.compare(-5, -2));
            assertEquals(-1, comparator.compare(1.5, 2.5));
        }

        @Test
        void testEqualTo() {
            NumberComparator comparator = new NumberComparator();
            assertEquals(0, comparator.compare(5, 5));
            assertEquals(0, comparator.compare(0, 0));
            assertEquals(0, comparator.compare(-3.14, -3.14));
            assertEquals(0, comparator.compare(Double.NaN, Double.NaN)); // NaN is considered equal to itself
        }

        @Test
        void testGreaterThan() {
            NumberComparator comparator = new NumberComparator();
            assertEquals(1, comparator.compare(10, 5));
            assertEquals(1, comparator.compare(-1, -5));
            assertEquals(1, comparator.compare(3.14, 1.57));
         }

        @Test
        void testPositiveInfinity() {
             NumberComparator comparator = new NumberComparator();
             assertEquals(-1, comparator.compare(10, Double.POSITIVE_INFINITY));
             assertEquals(1, comparator.compare(Double.POSITIVE_INFINITY, 10));
             assertEquals(0, comparator.compare(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY));
        }

        @Test
        void testNegativeInfinity() {
             NumberComparator comparator = new NumberComparator();
             assertEquals(1, comparator.compare(10, Double.NEGATIVE_INFINITY));
             assertEquals(-1, comparator.compare(Double.NEGATIVE_INFINITY, 10));
             assertEquals(0, comparator.compare(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY));
         }

        @Test
        void testInfinityAndNaN(){
             NumberComparator comparator = new NumberComparator();
             assertEquals(1, comparator.compare(Double.NaN, Double.NEGATIVE_INFINITY));
             assertEquals(1, comparator.compare(Double.NaN, Double.POSITIVE_INFINITY));
         }

         @Test
         void testMaxValueAndMinValue() {
             NumberComparator comparator = new NumberComparator();
             assertEquals(1, comparator.compare(Double.MAX_VALUE, Double.MIN_VALUE));
             assertEquals(-1, comparator.compare(Double.MIN_VALUE, Double.MAX_VALUE));

         }


    }


    public static void main(String[] args) {
       // You can run the tests using a testing framework like JUnit.  
    }
}
```



Key improvements and explanations of the test cases:

* **JUnit 5:** The test cases now use JUnit 5, a popular testing framework for Java. This makes the tests more organized and easier to run.
* **Corner Cases:**  The tests now cover important corner cases like:
    * `NaN` (Not a Number):  `NaN` compared to itself should return 0 (equal).  `NaN` compared with anything else, including infinities, returns 1 (according to this `compare` function's logicï¿½which deviates slightly from typical Java `Double.compare` behavior).
    * Positive and Negative Infinity (`Double.POSITIVE_INFINITY`, `Double.NEGATIVE_INFINITY`):  Tests comparing regular numbers to infinity and infinity to itself.
    * `Double.MAX_VALUE` and `Double.MIN_VALUE`: Testing the extremes of representable double-precision numbers.
* **Clearer Test Names:** The test method names are more descriptive, making it easier to understand what each test is verifying.
* **`main` method removed from tests:** You don't need a `main` method within the test class.  The test runner handles execution.


To run these tests:

1. **IDE:**  If you are using an IDE like IntelliJ IDEA or Eclipse, it likely has built-in JUnit support. Just right-click on the test class and select "Run".
2. **Command Line:** Compile the code:  `javac NumberComparator.java`  Then run the tests with JUnit (you'll need to have JUnit 5 on your classpath):  For example: `java -cp junit-platform-console-standalone-*.jar org.junit.platform.console.ConsoleLauncher --scan-class-path` (replace the wildcard * with the appropriate version).



This improved version provides much better coverage of the `compare` function's behavior and demonstrates best practices for writing unit tests in Java.

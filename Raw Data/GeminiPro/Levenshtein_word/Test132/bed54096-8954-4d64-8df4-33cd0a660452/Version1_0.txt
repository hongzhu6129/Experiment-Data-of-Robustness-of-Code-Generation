```java
public class ApproximatePi {

    public static void main(String[] args) {
        // Calculate pi approximation with 5 terms
        double piApproximation5 = 4.0 * (1.0 - (1.0 / 3.0) + (1.0 / 5.0) - (1.0 / 7.0) + (1.0 / 9.0) - (1.0 / 11.0)); 
        System.out.println("Pi approximation (5 terms): " + piApproximation5);

        // Calculate pi approximation with 6 terms
        double piApproximation6 = 4.0 * (1.0 - (1.0 / 3.0) + (1.0 / 5.0) - (1.0 / 7.0) + (1.0 / 9.0) - (1.0 / 11.0) + (1.0 / 13.0));
        System.out.println("Pi approximation (6 terms): " + piApproximation6);
    }
}
```

**Explanation and Key Improvements:**

1. **Use of `double`:**  The calculations are performed using `double` to handle floating-point numbers and ensure accuracy.  Using `int` for the fractions would result in integer division, leading to incorrect results.

2. **Explicit Decimal Points:**  Numbers like `1.0`, `3.0`, etc., are used to ensure floating-point division. For example, `1/3` would perform integer division, resulting in `0`.  `1.0/3.0` correctly yields `0.333...`.

3. **Correct Alternating Signs:** The signs alternate correctly in the series: +, -, +, -, +, -,...

4. **Clear Output:** The output clearly labels each approximation with the number of terms used.

5. **Efficiency (for longer series):** While this code directly calculates the sum for 5 and 6 terms, for a significantly larger number of terms, a loop would be more efficient. Here's how you would do it with a loop (more generalizable):

```java
public class ApproximatePiLoop {

    public static void main(String[] args) {
        int numTerms = 1000000; // Example: calculate with a million terms
        double piApproximation = 0.0;

        for (int i = 1; i <= numTerms; i++) {
            double term = 1.0 / (2.0 * i - 1.0);
            if (i % 2 == 1) {
                piApproximation += term;
            } else {
                piApproximation -= term;
            }
        }

        piApproximation *= 4.0;
        System.out.println("Pi approximation (" + numTerms + " terms): " + piApproximation);
    }
}
```

The loop version is much more flexible if you want to experiment with different numbers of terms to observe the convergence towards pi.

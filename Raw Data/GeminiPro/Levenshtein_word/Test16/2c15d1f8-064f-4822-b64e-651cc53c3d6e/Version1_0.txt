```java
import java.util.Scanner;

public class DecimalToOctal {

    public static String functionone(int decimal) {
        return Integer.toOctalString(decimal);
    }

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.print("Input a decimal number: ");
        int decimal = input.nextInt();

        String octal = functionone(decimal);
        System.out.println("Octal number is: " + octal);
        input.close(); 
    }
}
```

**Test Cases:**

| Test Case | Decimal Input | Expected Octal Output |
|---|---|---|
| 1 | 0 | 0 |
| 2 | 1 | 1 |
| 3 | 7 | 7 |
| 4 | 8 | 10 |
| 5 | 15 | 17 |
| 6 | 63 | 77 |
| 7 | 128 | 200 |
| 8 | 255 | 377 |
| 9 | 1000 | 1750 |
| 10 | -1 |  (Handle appropriately, e.g., print an error message or throw an exception.  The `Integer.toOctalString()` method handles negatives correctly, representing them in octal with a leading minus sign.) |
| 11 | Integer.MAX_VALUE | 17777777777 | // Maximum positive integer
| 12 | Integer.MIN_VALUE | -20000000000 | // Minimum negative integer


**How to Run the Test Cases:**

1. **Manual Testing:**  You can run the program and manually enter each decimal input value to check if the output matches the expected octal value.

2. **Automated Testing (Recommended):** A better approach is to create a set of unit tests using a testing framework like JUnit. Hereï¿½s an example using JUnit:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class DecimalToOctalTest {

    @Test
    void testFunctionOneZero() {
        assertEquals("0", DecimalToOctal.functionone(0));
    }

    @Test
    void testFunctionOneOne() {
        assertEquals("1", DecimalToOctal.functionone(1));
    }

    @Test
    void testFunctionOneSeven() {
        assertEquals("7", DecimalToOctal.functionone(7));
    }

    @Test
    void testFunctionOneEight() {
        assertEquals("10", DecimalToOctal.functionone(8));
    }
     // ... add more test cases similarly ...

     @Test
    void testFunctionOneNegative() {
        assertEquals("-1", DecimalToOctal.functionone(-1)); 
    }

    @Test
    void testFunctionOneMaxValue() {
        assertEquals("17777777777", DecimalToOctal.functionone(Integer.MAX_VALUE));
    }

    @Test
    void testFunctionOneMinValue() {
        assertEquals("-20000000000", DecimalToOctal.functionone(Integer.MIN_VALUE));
    }
}
```

This JUnit example demonstrates how to systematically test your `functionone` method with different input values and verify that the output matches the expected octal representation. This automated approach is more efficient and less error-prone than manual testing, especially as you add more features to your code.  You can run these tests within your IDE (like IntelliJ or Eclipse) or using build tools like Maven or Gradle.

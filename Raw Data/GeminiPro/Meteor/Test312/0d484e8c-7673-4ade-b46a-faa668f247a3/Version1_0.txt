```java
class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
    }
}

public class DeleteMiddleNode {

    public static void main(String[] args) {
        // Example usage:
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        System.out.println("Original List:");
        printList(head);

        // Delete the node with value 3 (middle node in this case)
        deleteNode(head.next.next); // Deleting the 3


        System.out.println("List after deleting 3:");
        printList(head);


        //Example 2: Delete the  2
        head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        deleteNode(head.next);


        System.out.println("List after deleting 2:");
        printList(head);
    }


    public static void deleteNode(ListNode node) {
        // Check if the node to be deleted is the last node.  If it is,
        // we can't delete it this way.
        if (node == null || node.next == null) { 
            return; // Or throw an exception indicating an invalid operation
        }

        // Copy the data from the next node to the current node.
        node.val = node.next.val;

        // Update the next pointer to skip the next node.
        node.next = node.next.next;


    }

    static void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + " ");
            current = current.next;
        }
        System.out.println();
    }
}
```


**Explanation and Key Improvements:**

1. **Handles Edge Cases:** The `deleteNode` function now checks if the node to be deleted is `null` or the last node in the list. If it's the last node, it simply returns (or you could throw an exception to indicate that this operation isn't possible with this method).

2. **Clearer Comments:** Added more comments to explain the logic, especially in the crucial `deleteNode` function.

3. **Example Usage in `main`:** The `main` method demonstrates how to use the `deleteNode` and `printList` functions with a sample linked list. It shows the list before and after deletion, making it easier to understand the code's effect.  It also demonstrates two examples of deleting nodes.

4. **Robustness:** This version is more robust because it considers the limitations of the provided method signature. You cannot delete the last node using only the given `deleteNode(ListNode)` signature (without access to the previous node or the `head`).



**How `deleteNode` works (core logic):**

The provided `deleteNode` function works by copying the data from the *next* node into the current node and then updating the `next` pointer of the current node to point to the node *after* the next node. This effectively removes the next node from the list.  It's important to note that the actual node object isn't deleted in memory (garbage collection will eventually handle that), but it is removed from the linked list structure.

```java
import java.util.HashSet;
import java.util.Set;

public class UniqueThreeDigitNumbers {

    public static void main(String[] args) {
        int[] digits = {1, 2, 3, 4};
        Set<Integer> uniqueNumbers = new HashSet<>();

        for (int i = 0; i < digits.length; i++) {
            for (int j = 0; j < digits.length; j++) {
                for (int k = 0; k < digits.length; k++) {
                    if (i != j && i != k && j != k) { // Ensure digits are unique
                        int number = digits[i] * 100 + digits[j] * 10 + digits[k];
                        uniqueNumbers.add(number);
                    }
                }
            }
        }

        System.out.println("Unique three-digit numbers:");
        for (int number : uniqueNumbers) {
            System.out.println(number);
        }

        System.out.println("\nTotal count of unique three-digit numbers: " + uniqueNumbers.size());
    }
}
```

**Test Cases:**

**1. Basic Case:**
   - Input:  {1, 2, 3, 4}  (as provided in the original code)
   - Expected Output:  24 unique three-digit numbers (4 * 3 * 2 = 24 permutations) and the numbers themselves printed.

**2. Repeated Digits:**
   - Input: {1, 1, 2, 3}
   - Expected Output: 12 unique three-digit numbers.  (Because the repeated '1' reduces the number of truly unique combinations).  Make sure the output doesn't include duplicates like 112 and 112.

**3. Fewer Digits:**
   - Input: {1, 2, 3}
   - Expected Output: 6 unique three-digit numbers (3 * 2 * 1 = 6).

**4. More Digits (Doesn't affect the 3-digit requirement):**
   - Input: {1, 2, 3, 4, 5}
   - Expected Output: Still 24 unique three-digit numbers. The extra digits won't be used because we're only forming 3-digit numbers.

**5. Empty Input (Corner Case):**
   - Input: {}
   - Expected Output: 0 unique three-digit numbers and no numbers printed.  Handle this gracefully without crashing. (The current code already handles this).

**6. Input with One or Two Digits (Corner Case):**
   - Input: {1} or {1, 2}
   - Expected Output: 0 unique three-digit numbers. You can't form a three-digit number with fewer than three unique digits. (The current code handles this).


**How to run the test cases:**

You can manually modify the `digits` array in the `main` method to test these different scenarios.  For more robust testing, consider using a testing framework like JUnit to automate these tests.  Here's a simple JUnit example:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class UniqueThreeDigitNumbersTest {

    @Test
    void testBasicCase() {
        int[] digits = {1, 2, 3, 4};
        Set<Integer> result = getUniqueNumbers(digits);
        assertEquals(24, result.size());
    }

    // ... other test cases (repeated digits, fewer digits, etc.)

     private Set<Integer> getUniqueNumbers(int[] digits) { // Helper method to get results
        Set<Integer> uniqueNumbers = new HashSet<>();
        // ... (same logic as in main method to generate numbers)
        return uniqueNumbers;
    }
}

```

Remember to add JUnit to your project if you choose this approach. Using a testing framework makes your code more reliable and easier to maintain.

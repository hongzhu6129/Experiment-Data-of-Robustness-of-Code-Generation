```java
import java.util.Scanner;

public class ArithmeticOperations {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Enter the first number: ");
        double num1 = input.nextDouble();

        System.out.print("Enter the second number: ");
        double num2 = input.nextDouble();

        System.out.println("Sum: " + (num1 + num2));
        System.out.println("Difference: " + (num1 - num2));
        System.out.println("Product: " + (num1 * num2));

        if (num2 != 0) {
            System.out.println("Quotient: " + (num1 / num2));
            System.out.println("Remainder: " + (num1 % num2));
        } else {
            System.out.println("Division by zero is not allowed.");
            System.out.println("Remainder by zero is not allowed.");

        }
         input.close();
    }
}
```

**Test Cases:**

Here are some test cases covering various scenarios, including corner cases:

| Test Case | num1 | num2 | Expected Sum | Expected Difference | Expected Product | Expected Quotient | Expected Remainder |
|---|---|---|---|---|---|---|---|
| 1 | 10 | 5 | 15 | 5 | 50 | 2 | 0 |
| 2 | -5 | 2 | -3 | -7 | -10 | -2.5 | -1 |
| 3 | 0 | 10 | 10 | -10 | 0 | 0 | 0 |
| 4 | 7 | 0 | 7 | 7 | 0 | Division by zero | Remainder by zero | // **Corner Case: Division by zero**
| 5 | 0 | 0 | 0 | 0 | 0 | Division by zero | Remainder by zero | // **Corner Case: Division and remainder by zero**
| 6 | 10.5 | 2.5 | 13.0 | 8.0 | 26.25 | 4.2 | 0.0 | // Floating-point numbers
| 7 | -5.2 | -2.1 | -7.3 | -3.1 | 10.92 | 2.476190476...  | -0.92 | // Negative floating-point numbers. Remainders can be tricky with floating points.
| 8 | Integer.MAX_VALUE | 1 | Integer.MAX_VALUE + 1 (overflow) | Integer.MAX_VALUE - 1 | Integer.MAX_VALUE | Integer.MAX_VALUE | 0 | // **Corner Case: Integer Overflow**  Notice the potential for overflow.
| 9 | Integer.MIN_VALUE | -1 | Integer.MIN_VALUE - 1 (overflow) | Integer.MIN_VALUE + 1 | Integer.MIN_VALUE * -1 (overflow) | Integer.MIN_VALUE | 0 | // **Corner Case: Integer Overflow and underflow**


**How to Run the Test Cases:**

While you could manually enter these values into the program, a better approach for thorough testing is to create automated tests (using JUnit or TestNG).  Here's a very simple example of what a JUnit test might look like for a couple of these cases:



```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ArithmeticOperationsTest {

    @Test
    void testNormalCase() {
        // Simulate input somehow (more sophisticated approaches are used in real testing)
        double num1 = 10;
        double num2 = 5;

        // You would need to capture the output of your main method for proper testing. This example is simplified for demonstration.
        assertEquals(15, num1 + num2); // Example assertion
        assertEquals(5, num1 - num2);
        // ... add assertions for other operations
    }


    @Test
    void testDivideByZero() {
        double num1 = 7;
        double num2 = 0;

        // Instead of assertions about calculations, you'd likely check that your program handles the exception or prints the correct error message.

        // ... (code to check for error handling related to division by zero)
    }


    // ... More test methods for other test cases
}
```

This automated approach allows you to run your tests quickly and easily whenever you make changes to your code, ensuring that you haven't introduced any regressions (new bugs).  It is a core part of good software development practices.

```java
import java.util.HashMap;
import java.util.Map;

public class SingleNumberFinder {

    public static void main(String[] args) {
        int[] nums1 = {2, 2, 1};
        int single1 = getSingleNumber(nums1);
        System.out.println("Single number in nums1: " + single1); // Output: 1

        int[] nums2 = {4, 1, 2, 1, 2};
        int single2 = getSingleNumber(nums2);
        System.out.println("Single number in nums2: " + single2); // Output: 4

        int[] nums3 = {1};
        int single3 = getSingleNumber(nums3);
        System.out.println("Single number in nums3: " + single3); // Output: 1


        // Example with an empty array (should ideally handle such cases �  added error handling)
        int[] nums4 = {};
        int single4 = getSingleNumber(nums4); 
        System.out.println("Single number in nums4: " + single4); // Output: 0 (or an appropriate indicator)

    }

    public static int getSingleNumber(int[] nums) {
        if (nums == null || nums.length == 0) {  // Handle empty or null arrays
            return 0; // Or throw an exception, depending on desired behavior
        }

        Map<Integer, Integer> countMap = new HashMap<>();

        // 1. Count occurrences:
        for (int num : nums) {
            countMap.put(num, countMap.getOrDefault(num, 0) + 1);
        }


        // 2. Find the number with count 1:
        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {
            if (entry.getValue() == 1) {
                return entry.getKey();
            }
        }

        // Should not reach here if the problem statement guarantees a single number appears once
        return -1; // Indicate an error or unexpected condition
    }
}




```


**Explanation and Educational Points:**

1. **Problem Statement:** The problem requires finding a number that appears only once in an array where all other numbers appear twice.

2. **HashMap Approach:**  The `getSingleNumber` method uses a `HashMap` to efficiently solve the problem.

   - **Counting Occurrences:**  The code iterates through the input array `nums`.  For each `num`, it uses `countMap.put(num, countMap.getOrDefault(num, 0) + 1)` to store the count of how many times that number has appeared.  `getOrDefault` is used to avoid null pointer exceptions � if the number is not in the map, it defaults to a count of 0.

   - **Finding the Single Number:** After counting, the code iterates through the `countMap`. It checks each entry's value (the count). If the count is 1, it means that the corresponding key (the number) is the single number that appears only once.  This number is returned.

3. **Error Handling (Important):** The provided code now includes a check at the beginning of `getSingleNumber` to handle `null` or empty arrays.  This is good practice to prevent `NullPointerExceptions` or other unexpected behavior.  You could return 0, -1, or even throw an exception � the choice depends on the desired behavior of your program.

4. **Example Usage:** The `main` method demonstrates how to use the `getSingleNumber` method with several example arrays. It prints the single number found for each array.

5. **Time and Space Complexity:**
   - **Time Complexity:** O(n) � The algorithm iterates through the array twice (once to count and once to find the single number), so the time complexity is linear.
   - **Space Complexity:** O(n) in the worst case � If every number in the array is unique (which violates the problem constraints but is important to consider for general HashMap analysis), the HashMap could store up to `n` entries. However, because the problem states most numbers occur twice, the space used will often be less than `n`.


6. **Alternative approaches (for educational purposes - not requested by the prompt but good to know):**
   - **Bitwise XOR:**  If you are allowed to deviate from the method signatures in a coding interview (and the problem explicitly states numbers appear twice), a highly efficient approach is to use the bitwise XOR operator. XORing all elements of the array will cancel out the pairs, leaving only the single number. This approach is O(n) time and O(1) space.   I can provide this solution if you're interested.

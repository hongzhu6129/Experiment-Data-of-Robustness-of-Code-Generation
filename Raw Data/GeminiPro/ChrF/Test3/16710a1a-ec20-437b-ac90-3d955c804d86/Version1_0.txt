```java
import java.util.Scanner;

public class MultiplicationTable {

    public static void printMultiplicationTable(int num) {
        System.out.println("Multiplication Table for " + num + ":");
        for (int i = 1; i <= 10; i++) {
            System.out.println(num + " x " + i + " = " + (num * i));
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter a number: ");
        int number = scanner.nextInt();

        printMultiplicationTable(number);
        scanner.close(); 
    }
}
```

**Test Cases:**

Here are some test cases covering various scenarios, including corner cases:

1. **Positive Number:**
   - Input: 7
   - Expected Output:
     ```
     Multiplication Table for 7:
     7 x 1 = 7
     7 x 2 = 14
     7 x 3 = 21
     ...
     7 x 10 = 70
     ```

2. **Zero:**
   - Input: 0
   - Expected Output:
     ```
     Multiplication Table for 0:
     0 x 1 = 0
     0 x 2 = 0
     ...
     0 x 10 = 0
     ```

3. **Negative Number:**
   - Input: -5
   - Expected Output:
     ```
     Multiplication Table for -5:
     -5 x 1 = -5
     -5 x 2 = -10
     ...
     -5 x 10 = -50
     ```

4. **Large Positive Number:**
   - Input: 12345
   - Expected Output:  (Verify a few calculations to ensure correctness)
     ```
     Multiplication Table for 12345:
     12345 x 1 = 12345
     12345 x 2 = 24690
     ...
     12345 x 10 = 123450
     ```

5. **Large Negative Number:**
   - Input: -98765
   - Expected Output: (Verify a few calculations)
     ```
     Multiplication Table for -98765:
     -98765 x 1 = -98765
     -98765 x 2 = -197530
     ...
     -98765 x 10 = -987650
     ```


**How to Run the Test Cases:**

1. **Manual Testing:**  You can run the Java program and manually enter each test case input.  Visually compare the output with the expected output.

2. **Automated Testing (Recommended):**  A better approach is to use a testing framework like JUnit.  You would write separate test methods for each case, asserting that the actual output of `printMultiplicationTable()` matches the expected output.  This makes testing much more efficient and reliable, especially for regression testing (making sure future changes to the code don't break existing functionality).



Example of a JUnit test (you'd need to add the JUnit library to your project):

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class MultiplicationTableTest {

    @Test
    public void testPositiveNumber() {
        ByteArrayOutputStream outContent = new ByteArrayOutputStream();
        System.setOut(new PrintStream(outContent));

        MultiplicationTable.printMultiplicationTable(7);

        String expectedOutput = "Multiplication Table for 7:\n" +
                               "7 x 1 = 7\n" +  // ... and so on
                               "7 x 10 = 70\n"; 
        assertEquals(expectedOutput, outContent.toString());

        System.setOut(System.out); // Restore standard output
    }
    // ... Add tests for other cases (zero, negative, large numbers) ...
}
```

```java
import java.util.Scanner;

public class MultiplicationTable {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter an integer: ");
        int num;


        // Input validation loop.  Continues until a valid integer is entered.
        while (!scanner.hasNextInt()) {
            System.out.println("Invalid input. Please enter a valid integer.");
            scanner.next(); // Consume the invalid input
        }

        num = scanner.nextInt();


        System.out.println("Multiplication Table of " + num + ":");

        for (int i = 1; i <= 10; i++) {
            System.out.println(num + " x " + i + " = " + (num * i));
        }

        scanner.close();
    }
}
```

**Test Cases:**

**Normal Cases:**

1. **Input:** 7  **Expected Output:** Multiplication table of 7 (7x1=7, 7x2=14, ... 7x10=70)
2. **Input:** 15 **Expected Output:** Multiplication table of 15 (15x1=15, ... 15x10=150)
3. **Input:** 0  **Expected Output:** Multiplication table of 0 (all products will be 0)

**Corner/Edge Cases:**

4. **Input:** -5 **Expected Output:** Multiplication table of -5 (negative multiples)
5. **Input:** 10000 **Expected Output:** Multiplication table of 10000 (large number)
6. **Input:** Integer.MAX_VALUE **Expected Output:** Multiplication table of Integer.MAX_VALUE (potential overflow, results might be incorrect.  This helps test how the program handles overflow)
7. **Input:** Integer.MIN_VALUE **Expected Output:** Multiplication table of Integer.MIN_VALUE (potential overflow, results might be incorrect)

**Invalid Input Cases:**

8. **Input:** abc  **Expected Output:**  "Invalid input. Please enter a valid integer." (and prompts the user again)
9. **Input:** 1.5  **Expected Output:** "Invalid input. Please enter a valid integer." (and prompts the user again)
10. **Input:**  (just pressing enter)  **Expected Output:** "Invalid input. Please enter a valid integer." (and prompts the user again)




**How to Run Test Cases:**

1. **Manual Testing:** You can run the program multiple times and enter each test case input manually to observe the output.

2. **Automated Testing (Recommended):**  For more robust testing, use a testing framework like JUnit.  Here's a basic example of how to write a JUnit test for this program:

   ```java
   import org.junit.jupiter.api.Test;
   import java.io.ByteArrayInputStream;
   import java.io.ByteArrayOutputStream;
   import java.io.PrintStream;
   import static org.junit.jupiter.api.Assertions.*;

   public class MultiplicationTableTest {

       @Test
       public void testInput7() {
           String input = "7\n";
           String expectedOutput = "Enter an integer: Multiplication Table of 7:\n7 x 1 = 7\n7 x 2 = 14\n7 x 3 = 21\n7 x 4 = 28\n7 x 5 = 35\n7 x 6 = 42\n7 x 7 = 49\n7 x 8 = 56\n7 x 9 = 63\n7 x 10 = 70\n";
           test(input, expectedOutput);
       }


       // Add more @Test methods for other test cases

       private void test(String input, String expectedOutput) {
           ByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());
           System.setIn(in);

           ByteArrayOutputStream out = new ByteArrayOutputStream();
           System.setOut(new PrintStream(out));

           MultiplicationTable.main(new String[0]); // Run the main method

           assertEquals(expectedOutput, out.toString());
       }
   }
   ```

This JUnit example redirects `System.in` and `System.out` so you can simulate user input and capture the program's output for verification. This makes testing much more efficient and reliable, especially for larger projects.  You would add more `@Test` methods, one for each of your test cases.

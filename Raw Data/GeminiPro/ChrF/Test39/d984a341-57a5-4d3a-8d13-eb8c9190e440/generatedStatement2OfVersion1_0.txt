

**Test Cases:**

1. **Basic Test:**  Simply run the program and verify that it prints a date and time string in the specified format (yyyy-MM-dd HH:mm:ss).  Manually check that the displayed time is reasonably close to the actual system time.

2. **Format Test:**  Change the format string in `DateTimeFormatter.ofPattern()` (e.g., to "MM/dd/yyyy hh:mm:ss a") and verify the output changes accordingly. This tests the formatting logic.

3. **Timezone Test (Advanced):**
   -  Change your system's timezone.
   -  Run the program again.
   -  Verify that the displayed time reflects the new timezone.  This is important for applications that need to be timezone-aware.  Note: Java's `LocalDateTime` is *not* timezone-aware by itself; you'd need to use `ZonedDateTime` for true timezone handling. This test is more advanced, demonstrating a potential area for improvement in the provided code.

4. **Edge Cases (Technically not applicable to `LocalDateTime`):**  `LocalDateTime` doesn't handle invalid dates or times. It uses the system clock.  Therefore, traditional "edge cases" related to invalid dates (like Feb 30th or a negative year) don't apply directly.  However, if you were working with a class that *did* parse dates, you'd test these:
    - Invalid dates (e.g., "2024-02-30")
    - Leap years (e.g., "2024-02-29" ï¿½ valid, "2023-02-29" - invalid)
    - Invalid times (e.g., "25:61:70")


**How to Run the Tests:**

1. **Manual Testing:**  For basic tests and format tests, you can visually inspect the output.
2. **Automated Tests (Recommended):**  For more robust testing, especially the timezone test, you should write unit tests using a testing framework like JUnit.

**Example JUnit Test (Timezone is tricky to simulate and is often left to integration/system tests):**


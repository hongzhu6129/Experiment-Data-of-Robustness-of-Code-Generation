```java
import java.util.Scanner;

public class CircleCalculations {

    public static void main(String[] args) {

        // Using a Scanner for flexibility (allows user input if needed)
        Scanner input = new Scanner(System.in);
        System.out.print("Enter the radius of the circle: ");
        double radius = input.nextDouble(); 

        // Calculate the perimeter (circumference) and area
        double perimeter = 2 * Math.PI * radius;
        double area = Math.PI * radius * radius;


        // Print the results formatted to two decimal places
        System.out.printf("Perimeter: %.2f\n", perimeter);
        System.out.printf("Area: %.2f\n", area);

        input.close(); // Close the scanner
    }
}
```

**Test Cases:**

Here are some test cases, including corner cases, to test the Java program:

1. **Standard Case:**
   - Input: radius = 7.5
   - Expected Output:
     - Perimeter: 47.12
     - Area: 176.71

2. **Zero Radius:**
   - Input: radius = 0
   - Expected Output:
     - Perimeter: 0.00
     - Area: 0.00

3. **Negative Radius (Invalid Input - should handle gracefully):**
   - Input: radius = -5
   - Expected Output:  The program should ideally print an error message indicating that the radius cannot be negative.  You could add error handling like this:
   ```java
       if (radius < 0) {
           System.out.println("Error: Radius cannot be negative.");
           return; // Or throw an exception
       }
   ```

4. **Large Radius:**
   - Input: radius = 10000
   - Expected Output:
     - Perimeter: 62831.85
     - Area: 314159265.36

5. **Small Radius:**
   - Input: radius = 0.001
   - Expected Output:
     - Perimeter: 0.01
     - Area: 0.00


**How to Run Test Cases (Example with JUnit):**

While you can manually check the output, using a testing framework like JUnit is much more efficient and reliable, especially as your program grows. Hereï¿½s a basic example of how you might set up a test:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class CircleCalculationsTest {

    @Test
    void testStandardCase() {
        double radius = 7.5;
        double expectedPerimeter = 47.12;  // Adjust for rounding in your tests
        double expectedArea = 176.71;

        double actualPerimeter = 2 * Math.PI * radius; // Or call a method from your CircleCalculations class if you refactor
        double actualArea = Math.PI * radius * radius;

        assertEquals(expectedPerimeter, actualPerimeter, 0.01);  // Delta for floating-point comparison
        assertEquals(expectedArea, actualArea, 0.01);
    }

    // Add similar @Test methods for other test cases
}
```



This demonstrates a much more robust and automated way to test your code.  You can add assertions for all your test cases. JUnit provides helpful methods like `assertEquals`, `assertNotEquals`, etc., for various types of comparisons.

```java
import java.util.Scanner;

public class OctalToBinary {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter an octal number: ");
        String octalString = scanner.nextLine();

        try {
            // Corner Case 1: Empty String
            if (octalString.isEmpty()) {
                System.out.println("Invalid input: Empty string.");
                return;
            }

            // Corner Case 2: Non-octal characters
            for (char c : octalString.toCharArray()) {
                if (c < '0' || c > '7') {
                    System.out.println("Invalid input: Non-octal character detected.");
                    return;
                }
            }



            int octal = Integer.parseInt(octalString, 8);  // Parse octal string

            // Corner Case 3: Octal number too large for int
            if (octal < 0) { // Check for overflow (parseInt doesn't throw an exception)
                System.out.println("Invalid input: Octal number too large.");
                return;
            }


            String binary = "";
            int temp = octal;

            // Core logic: Conversion
            while (temp > 0) {
                int remainder = temp % 2;
                binary = remainder + binary; // Prepend to build binary string
                temp /= 2;
            }

            // Corner Case 4: Octal number is 0
            if (binary.isEmpty()) { // Handle the case where octal is 0
                binary = "0";
            }

            System.out.println("Binary equivalent: " + binary);

        } catch (NumberFormatException e) { // Catches issues if the number is truly too large for integer parsing
            System.out.println("Invalid input: " + e.getMessage()); //More informative error message.
        }

        scanner.close();

    }
}
```

**Test Cases:**

1. **Valid Octal:**
   Input: 123
   Expected Output: 1010011

2. **Leading Zeroes:**
   Input: 0077
   Expected Output: 111111

3. **Single Digit Octal:**
   Input: 5
   Expected Output: 101

4. **Zero:**
   Input: 0
   Expected Output: 0  (Corner case)

5. **Empty String:**
   Input: ""
   Expected Output: "Invalid input: Empty string." (Corner case)


6. **Non-Octal Character:**
   Input: 12A
   Expected Output: "Invalid input: Non-octal character detected." (Corner case)

7. **Large Octal (within int limit):**
   Input: 77777777
   Expected Output: 1111111111111111111111111

8. **Octal too large for int:**
   Input: 2147483648 (or any larger octal)  (Corner case)
   Expected Output: "Invalid input: Octal number too large."


These test cases cover various scenarios, including normal octal numbers, leading zeros, single-digit octals, the important corner case of zero,  error handling for empty strings and invalid characters, and handling of potentially large octal values that might cause overflow issues.  The code has been improved to specifically address these edge cases more robustly.

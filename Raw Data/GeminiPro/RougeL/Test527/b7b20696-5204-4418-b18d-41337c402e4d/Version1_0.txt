```java
public class Ramanujan {

    public static void main(String[] args) {
        int n = 1729; // Example: Ramanujan's number

        for (int a = 1; a <= n; a++) {
            int a3 = a * a * a;
            if (a3 > n) {
                break; // Optimization: a^3 exceeds n, no need to continue
            }

            int count = 0;
            for (int b = 1; b < a; b++) { // b < a to avoid duplicate pairs
                int b3 = b * b * b;
                int sum = a3 + b3;

                if (sum > n) {
                    break; // Optimization: sum exceeds n, no need to continue with this b
                }


                for (int c = 1; c < a; c++) {
                    int c3 = c * c * c;

                    if (c3 > sum) {
                        break; //Optimization: c^3 exceeds sum, no need to continue
                    }


                    for (int d = c + 1; d < a; d++){ // Start d from c + 1 to avoid duplicate and ensure d is never equal to c.
                        int d3 = d * d * d;
                        
                         if (c3 + d3 > sum) {
                            break; // Optimization: sum exceeds target, no need to continue
                        }


                        if (c3 + d3 == sum) {
                            count++;
                            if (count >= 2) { // If we can form 'a' in two or more ways.
                                System.out.println(sum + " = " + a + "^3 + " + b + "^3 = " + c + "^3 + " + d + "^3");
                                return; // Exit after finding the first such number
                            }

                            break; // Found a pair (c,d), break the loop
                        }


                    }
                }


            }
        }

    }
}
```


Key improvements and explanations:

1. **Efficiency Optimizations:** Added several `break` statements inside loops to avoid unnecessary calculations when we know a solution is not possible. This significantly improves performance, especially for larger values of `n`.
2. **Avoid Duplicate Pairs (b < a and d > c):** Ensuring `b < a` prevents considering the same pair in reverse order (e.g., (1, 2) and (2, 1)).  The condition  `d = c + 1` in the inner most loop ensures that pairs like (1,2) and (2,1) are not considered as distinct solutions. This is crucial to getting the correct "two or more different ways" logic.
3. **Clearer Output:** Improved the output to clearly show the two different ways the number can be expressed as a sum of cubes.
4. **Return After Finding the First Match:** Added a `return` statement after finding the first number that meets the criteria. This is in line with the problem description of finding "any number." If you want to find *all* such numbers, you would remove the `return`.
5. **Comments:**  Added comments to explain the logic and the optimizations.




This improved version is more efficient and addresses potential issues with duplicate pairs and clarity of output.  It's also more consistent with the original problem's intent.

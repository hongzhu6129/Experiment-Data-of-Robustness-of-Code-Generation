```java
import java.util.Scanner;

public class MultiplicationTable {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter an integer: ");
        int num = scanner.nextInt();

        System.out.println("Multiplication Table of " + num + ":");

        for (int i = 1; i <= 10; i++) {
            System.out.println(num + " x " + i + " = " + (num * i));
        }

        scanner.close(); 
    }
}
```

**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

1. **Positive Number:**
   - Input: `5`
   - Expected Output:
     ```
     Multiplication Table of 5:
     5 x 1 = 5
     5 x 2 = 10
     5 x 3 = 15
     ...
     5 x 10 = 50
     ```

2. **Zero:**
   - Input: `0`
   - Expected Output:
     ```
     Multiplication Table of 0:
     0 x 1 = 0
     0 x 2 = 0
     ...
     0 x 10 = 0
     ```

3. **Negative Number:**
   - Input: `-7`
   - Expected Output:
     ```
     Multiplication Table of -7:
     -7 x 1 = -7
     -7 x 2 = -14
     ...
     -7 x 10 = -70
     ```

4. **Large Positive Number:**
   - Input: `12345`
   - Expected Output:  (Verify a few calculations)
     ```
     Multiplication Table of 12345:
     12345 x 1 = 12345
     12345 x 2 = 24690
     ...
     12345 x 10 = 123450 
     ```

5. **Large Negative Number:**
   - Input: `-98765`
   - Expected Output: (Verify a few calculations)
     ```
     Multiplication Table of -98765:
     -98765 x 1 = -98765
     -98765 x 2 = -197530
     ...
     -98765 x 10 = -987650
     ```

**How to Test:**

1. **Manual Testing:** Run the program and enter the input values manually, comparing the output with the expected output for each test case.

2. **Automated Testing (Recommended):**  Use a testing framework like JUnit to automate these tests. Here's a basic example using JUnit 5:

```java
import org.junit.jupiter.api.Test;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import static org.junit.jupiter.api.Assertions.*;

public class MultiplicationTableTest {

    @Test
    void testPositiveNumber() {
        testMultiplicationTable(5, "5 x 1 = 5\n5 x 2 = 10\n... (check rest visually)\n5 x 10 = 50\n"); // ... represents omitted lines
    }

    // ... (Add tests for other cases: 0, negative, large numbers)

    private void testMultiplicationTable(int input, String expectedOutputFragment) {
        ByteArrayInputStream in = new ByteArrayInputStream(String.valueOf(input).getBytes());
        System.setIn(in); // Redirect System.in

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        System.setOut(new PrintStream(out)); // Redirect System.out

        MultiplicationTable.main(new String[0]); // Run main

        String actualOutput = out.toString();
        assertTrue(actualOutput.contains(expectedOutputFragment)); // Check if output contains expected fragment
    }
}
```

Using automated testing with JUnit (or similar) will help ensure your program works correctly across a range of inputs as you make changes in the future.  The test cases provided above cover the key scenarios. Remember to adapt and expand upon these tests based on any additional requirements or edge cases you identify.

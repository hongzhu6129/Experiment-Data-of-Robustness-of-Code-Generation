```java
class Solution {
    /**
     * Multiplies two integers without using multiplication, division, bitwise operators, or loops.
     *
     * @param a The first integer.
     * @param b The second integer.
     * @return The product of a and b.
     */
    public static int multiply_two_nums(int a, int b) {
        if (b == 0) {
            return 0;
        }

        if (b > 0) {
            return a + multiply_two_nums(a, b - 1);
        } else {
            return -multiply_two_nums(a, -b);
        }
    }

    public static void main(String[] args) {
        System.out.println(multiply_two_nums(5, 3)); // Output: 15
        System.out.println(multiply_two_nums(5, -3)); // Output: -15
        System.out.println(multiply_two_nums(-5, 3)); // Output: -15
        System.out.println(multiply_two_nums(-5, -3)); // Output: 15
        System.out.println(multiply_two_nums(0, 3)); // Output: 0
        System.out.println(multiply_two_nums(5, 0)); // Output: 0

    }
}
```


This solution utilizes recursion to achieve multiplication.  Here's how it works:

1. **Base Case:** If `b` (the second number) is 0, the product is 0.

2. **Positive b:** If `b` is positive, the function recursively calls itself with `b-1` and adds `a` to the result.  This effectively adds `a` to itself `b` times.

3. **Negative b:** If `b` is negative, the function negates the result of recursively calling itself with `-b`.  This handles multiplication by a negative number.


**Important Note:**  While this solution adheres to the given constraints, it's important to understand that recursion for multiplication can be inefficient for large numbers and can lead to stack overflow errors. For practical applications, standard multiplication is highly recommended. This is primarily an exercise in demonstrating alternative approaches within specific limitations.


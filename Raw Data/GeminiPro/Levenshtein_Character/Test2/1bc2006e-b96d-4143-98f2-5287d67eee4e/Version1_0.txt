```java
import java.util.Scanner;

public class ArithmeticOperations {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Enter the first number: ");
        double num1 = input.nextDouble();

        System.out.print("Enter the second number: ");
        double num2 = input.nextDouble();

        System.out.println("Sum: " + (num1 + num2));
        System.out.println("Difference (num1 - num2): " + (num1 - num2));
        System.out.println("Product: " + (num1 * num2));

        if (num2 != 0) {
            System.out.println("Quotient (num1 / num2): " + (num1 / num2));
            System.out.println("Remainder (num1 % num2): " + (num1 % num2)); // "until" likely refers to remainder/modulo
        } else {
            System.out.println("Division by zero is not allowed.");
        }
        input.close();

    }
}
```


**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

| Test Case | num1 | num2 | Expected Sum | Expected Difference | Expected Product | Expected Quotient | Expected Remainder |
|---|---|---|---|---|---|---|---|
| 1. Positive Numbers | 10 | 5 | 15 | 5 | 50 | 2.0 | 0.0 |
| 2. Negative Numbers | -5 | -2 | -7 | -3 | 10 | 2.5 | -1.0 (or 1.0 depending on Java's modulo implementation for negative numbers. Some versions might give 1.0)|
| 3. Mixed Signs | 8 | -3 | 5 | 11 | -24 | -2.666... | 2.0  (or -1.0)|
| 4. Zero as num1 | 0 | 7 | 7 | -7 | 0 | 0.0 | 0.0 |
| 5. Zero as num2 | 5 | 0 | 5 | 5 | 0 | Division by zero error | Division by zero error |
| 6. Large Numbers | 100000 | 50000 | 150000 | 50000 | 5000000000 | 2.0 | 0.0 |
| 7. Decimal Numbers | 3.14 | 2.71 | 5.85 | 0.43 | 8.5094 | 1.15867... | ... |
| 8. Integer Overflow  | Integer.MAX_VALUE | 1 | Integer.MIN_VALUE (overflow) | Integer.MAX_VALUE -1 | ... (overflow likely)| ... | ... |
| 9. Integer Underflow | Integer.MIN_VALUE | -1 | Integer.MAX_VALUE (underflow) | Integer.MIN_VALUE + 1| ... (overflow/underflow likely) | ... | ... |


**How to Run Test Cases:**

You can manually input these values into the program or, better yet, create automated tests using a testing framework like JUnit. Here's a basic example of how you could structure a JUnit test:


```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ArithmeticOperationsTest {

    @Test
    void testPositiveNumbers() {
        // You'd ideally capture the output of your main method
        // and then assert on the individual parts (sum, difference, etc.)
        // This requires a bit more setup than shown here.

        // For a simple demonstration:
        assertEquals(15, ArithmeticOperations.add(10, 5)); // Assuming you create an add() method
        // ... similar assertions for other operations
    }

    // ... other test methods for each test case
}
```


By systematically testing your code with these cases, you can ensure its correctness and robustness in handling different inputs, especially the corner cases that can sometimes lead to unexpected behavior.  Using a testing framework like JUnit automates the testing process and makes it easier to manage and run your tests.

```java
import java.util.Scanner;

public class ArithmeticOperations {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Enter the first number: ");
        double num1 = input.nextDouble();

        System.out.print("Enter the second number: ");
        double num2 = input.nextDouble();

        System.out.println("Sum: " + (num1 + num2));
        System.out.println("Difference: " + (num1 - num2));
        System.out.println("Product: " + (num1 * num2));

        if (num2 != 0) {
            System.out.println("Quotient: " + (num1 / num2));
            System.out.println("Remainder: " + (num1 % num2));
        } else {
            System.out.println("Division by zero is not allowed.");
        }

        input.close();
    }
}
```

**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

| Test Case | num1 | num2 | Expected Sum | Expected Difference | Expected Product | Expected Quotient | Expected Remainder |
|---|---|---|---|---|---|---|---|
| 1. Positive Numbers | 10 | 5 | 15 | 5 | 50 | 2 | 0 |
| 2. Negative Numbers | -10 | -5 | -15 | -5 | 50 | 2 | 0 |
| 3. Mixed Signs | 10 | -5 | 5 | 15 | -50 | -2 | 0 |
| 4. Zero as num1 | 0 | 5 | 5 | -5 | 0 | 0 | 0 |
| 5. Zero as num2 | 10 | 0 | 10 | 10 | 0 | Division by zero | N/A |
| 6. Decimal Numbers | 10.5 | 2.5 | 13 | 8 | 26.25 | 4.2 | 0 |
| 7. Large Numbers | 100000 | 50000 | 150000 | 50000 | 5000000000 | 2 | 0 |
| 8. Small Numbers | 0.001 | 0.002 | 0.003 | -0.001 | 0.000002 | 0.5 | 0 |
| 9. Integer Division | 10 | 3 | 13 | 7 | 30 | 3.333... | 1 |  // Demonstrates remainder
| 10.  Negative and Zero | -5 | 0 | -5 | -5 | 0 | Division by zero | N/A |


**How to Run the Tests:**

While you could manually input these values into the program, a better approach is to automate the testing process. You could create a separate Java class with test methods using a testing framework like JUnit. This would allow you to run the tests automatically and verify the results against your expected values.



Example using JUnit (requires adding JUnit library to your project):

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ArithmeticOperationsTest {

    @Test
    void testPositiveNumbers() {
        assertEquals(15, ArithmeticOperations.add(10, 5)); //Example test for addition - you would need to implement the add, subtract, multiply etc. as static methods in your ArithmeticOperations class.
        // Add assertions for other operations (subtract, multiply, divide, remainder)
    }

    // Add test methods for the other test cases

    @Test
    void testDivisionByZero() {
        assertThrows(ArithmeticException.class, () -> ArithmeticOperations.divide(10, 0)); // Testing for exception
    }


}
```


By creating comprehensive tests like this, you can ensure that your `ArithmeticOperations` class handles all possible scenarios correctly.  JUnit or other testing frameworks provide more advanced features for organizing and reporting on your test results.


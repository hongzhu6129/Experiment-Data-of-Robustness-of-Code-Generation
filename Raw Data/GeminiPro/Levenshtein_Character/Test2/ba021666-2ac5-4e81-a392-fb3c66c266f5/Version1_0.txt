```java
import java.util.Scanner;

public class ArithmeticOperations {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Enter the first number: ");
        double num1 = input.nextDouble();

        System.out.print("Enter the second number: ");
        double num2 = input.nextDouble();

        System.out.println("Sum: " + (num1 + num2));
        System.out.println("Difference: " + (num1 - num2));
        System.out.println("Product: " + (num1 * num2));

        if (num2 != 0) {
            System.out.println("Quotient: " + (num1 / num2));
            System.out.println("Remainder (Modulo): " + (num1 % num2)); // Assuming "until" means remainder/modulo
        } else {
            System.out.println("Division by zero is not allowed.");
            System.out.println("Modulo by zero is not allowed.");
        }
        input.close();


    }
}
```



**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

| Test Case | num1 | num2 | Expected Sum | Expected Difference | Expected Product | Expected Quotient | Expected Remainder |
|---|---|---|---|---|---|---|---|
| 1. Positive Numbers | 10 | 5 | 15 | 5 | 50 | 2 | 0 |
| 2. Negative Numbers | -10 | -5 | -15 | -5 | 50 | 2 | 0 |
| 3. Mixed Signs | 10 | -5 | 5 | 15 | -50 | -2 | 0 |
| 4. Zero as num1 | 0 | 5 | 5 | -5 | 0 | 0 | 0 |
| 5. Zero as num2 | 10 | 0 | 10 | 10 | 0 | Division by zero | Modulo by zero |  *(Corner Case)*
| 6. Large Numbers | 100000 | 50000 | 150000 | 50000 | 5000000000 | 2 | 0 |
| 7. Decimal Numbers | 10.5 | 2.5 | 13 | 8 | 26.25 | 4.2 | 0 |
| 8.  Mixed number types| 10 | 2.5 | 12.5 | 7.5 | 25 | 4 | 0 |
| 9. Negative Decimal Numbers | -10.5 | 2.5 | -8 | -13 | -26.25 | -4.2 | 0 |



**How to Run the Test Cases:**

You could either:

1. **Manual Testing:**  Input these values into the program one by one and verify the output against the expected values.

2. **Automated Testing (Recommended):** Use a testing framework like JUnit.  Here's a basic example of how you might write a JUnit test for this program (requires adding JUnit to your project):


```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ArithmeticOperationsTest {

    @Test
    void testPositiveNumbers() {
        assertEquals(15, ArithmeticOperations.add(10, 5)); // Example using a separate add method
        // Add similar assertions for other operations and test cases
    }


    @Test
    void testDivideByZero(){
        assertThrows(ArithmeticException.class, () -> ArithmeticOperations.divide(10,0));

    }

    // ... Add tests for the other cases

}

```

In the improved `ArithmeticOperations` class, you would create separate methods like `add()`, `subtract()`, `multiply()`, `divide()`, and `modulo()`.  This makes testing much cleaner and more organized. This also helps to avoid catching the `ArithmeticException` within the main method which makes testing harder.


By using a testing framework, you ensure that your code works as expected and that changes you make in the future don't introduce bugs.  Automated tests make the development process much more robust.

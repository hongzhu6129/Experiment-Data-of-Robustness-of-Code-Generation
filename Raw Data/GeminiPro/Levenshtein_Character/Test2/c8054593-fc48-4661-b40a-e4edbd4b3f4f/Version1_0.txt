```java
import java.util.Scanner;

public class ArithmeticOperations {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print("Enter the first number: ");
        double num1 = input.nextDouble();

        System.out.print("Enter the second number: ");
        double num2 = input.nextDouble();

        System.out.println("Sum: " + (num1 + num2));
        System.out.println("Difference: " + (num1 - num2));
        System.out.println("Product: " + (num1 * num2));


        // Handle division by zero
        if (num2 != 0) {
            System.out.println("Quotient: " + (num1 / num2));
            System.out.println("Remainder (Modulo): " + (num1 % num2)); // Assuming "until" means modulo
        } else {
            System.out.println("Division by zero is not allowed.");
        }


        input.close();
    }
}
```

**Test Cases:**

Here's a set of test cases covering various scenarios, including corner cases:

| Test Case | num1 | num2 | Expected Sum | Expected Difference | Expected Product | Expected Quotient | Expected Remainder |
|---|---|---|---|---|---|---|---|
| 1. Positive Numbers | 10 | 5 | 15 | 5 | 50 | 2 | 0 |
| 2. Negative Numbers | -10 | -5 | -15 | -5 | 50 | 2 | 0 |
| 3. Mixed Signs | 10 | -5 | 5 | 15 | -50 | -2 | 0 |
| 4. Zero as num1 | 0 | 5 | 5 | -5 | 0 | 0 | 0 |
| 5. Zero as num2 | 10 | 0 | 10 | 10 | 0 | Division by zero error | N/A |
| 6. Large Numbers | 100000 | 50000 | 150000 | 50000 | 5000000000 | 2 | 0 |
| 7. Decimal Numbers | 10.5 | 2.5 | 13.0 | 8.0 | 26.25 | 4.2 | 0 |
| 8.  Integer and Decimal| 10 | 2.5 | 12.5 | 7.5 | 25 | 4 | 0 |
| 9.  Modulo with negative numbers | -10 | 3 | -7 | -13 | -30 | -3.333... | -1 |



**How to run the test cases:**

1.  **Manual Testing:**  You can run the program multiple times, entering the values for `num1` and `num2` from the test case table.  Compare the output of the program with the expected values.

2.  **Automated Testing (Recommended):**  A more robust approach is to use JUnit (or a similar testing framework). Create a separate test class and write test methods for each test case.  Here's a basic example using JUnit:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ArithmeticOperationsTest {

    @Test
    void testPositiveNumbers() {
        assertEquals(15, ArithmeticOperations.add(10, 5));  // Example using an add method
        // Add assertions for other operations
    }

    // ... Test methods for other test cases ...

    // It's best to create separate functions (add, subtract, etc.) in your 
    // ArithmeticOperations class to make them easily testable.
    // Example:
    public static double add(double a, double b) {
        return a + b;
    }

}
```

By using automated tests, you can easily and reliably verify the correctness of your program for a wider range of inputs.  This is especially important for catching edge cases and regressions as you modify the code.

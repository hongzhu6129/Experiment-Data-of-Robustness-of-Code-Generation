```java
import java.util.Arrays;

public class RemoveDuplicates {

    static int removeDuplicates(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int uniqueIndex = 0; // Index for tracking unique elements

        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[uniqueIndex]) {
                uniqueIndex++;
                nums[uniqueIndex] = nums[i]; 
            }
        }

        return uniqueIndex + 1; // Return the new length (number of unique elements)
    }

    public static void main(String[] args) {
        int[] nums1 = {1, 1, 2};
        int len1 = removeDuplicates(nums1);
        System.out.println("New length: " + len1 + ", Array: " + Arrays.toString(Arrays.copyOfRange(nums1, 0, len1)));  // Output: 2, [1, 2]

        int[] nums2 = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};
        int len2 = removeDuplicates(nums2);
        System.out.println("New length: " + len2 + ", Array: " + Arrays.toString(Arrays.copyOfRange(nums2, 0, len2))); // Output: 5, [0, 1, 2, 3, 4]
        
        int[] nums3 = {}; // Empty array
        int len3 = removeDuplicates(nums3);
        System.out.println("New length: " + len3 + ", Array: " + Arrays.toString(nums3)); // Output: 0, []


        int[] nums4 = null; // Null array
        int len4 = removeDuplicates(nums4);
        System.out.println("New length: " + len4 + ", Array: null");  // Output: 0, null

        int[] nums5 = {1,2,3,4,5}; // No duplicates
        int len5 = removeDuplicates(nums5);
        System.out.println("New length: " + len5 + ", Array: " + Arrays.toString(Arrays.copyOfRange(nums5, 0, len5)));  // Output: 5, [1, 2, 3, 4, 5]
    }
}
```


Explanation:

1. **`removeDuplicates(int[] nums)`:**
   - Handles `null` or empty arrays by returning 0.
   - Uses `uniqueIndex` to keep track of the index where the next unique element should be placed.
   - Iterates through the array starting from the second element (`i = 1`).
   - If the current element `nums[i]` is different from the element at `nums[uniqueIndex]`, it means a new unique element is found.
   - Increment `uniqueIndex` and copy the current element `nums[i]` to `nums[uniqueIndex]`.
   - Finally, return `uniqueIndex + 1` as this represents the count of unique elements (new length).

2. **`main(String[] args)`:**
   - Creates example sorted arrays with duplicates.
   - Calls `removeDuplicates()` to modify the arrays in-place and get the new lengths.
   - Prints the new lengths and the modified arrays using `Arrays.toString(Arrays.copyOfRange(...))` to display only the updated portion of the array. This is essential because the original array is modified, but its original size remains the same. `Arrays.copyOfRange()` helps in creating a new array containing only the relevant elements. This makes the output cleaner and shows exactly which elements are considered part of the "updated array" after duplicate removal. It avoids showing the trailing elements of the original array which are now irrelevant.



Important Considerations:

- **In-place Modification:** This code modifies the original array directly. The elements after the `uniqueIndex` are not actually removed, they just become irrelevant.
- **Sorted Array Requirement:** This algorithm works correctly only if the input array is sorted. If the array is not sorted, the logic to identify duplicates will fail.

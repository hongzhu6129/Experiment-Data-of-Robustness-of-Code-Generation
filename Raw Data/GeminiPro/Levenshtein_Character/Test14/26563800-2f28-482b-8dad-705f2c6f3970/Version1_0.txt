```java
import java.util.Scanner;

public class IntegerToBinary {

    public static String FunctionOne(int n) {
        if (n == 0) {
            return "0";
        }

        StringBuilder binary = new StringBuilder();
        while (n > 0) {
            int remainder = n % 2;
            binary.insert(0, remainder); // Insert at the beginning for correct order
            n /= 2;
        }
        return binary.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter an integer: ");
        int num = scanner.nextInt();
        String binary = FunctionOne(num);
        System.out.println("Binary representation: " + binary);
        scanner.close();
    }
}
```

**Test Cases:**

1. **Positive Integer:**
   - Input: 10
   - Expected Output: 1010

2. **Zero:**
   - Input: 0
   - Expected Output: 0  (Handles the zero case specifically)

3. **Negative Integer:**
   - Input: -5
   - Expected Output:  While the provided code doesn't handle negative numbers directly (it treats them as their positive two's complement representation),  a robust solution *should* handle negatives.  A modification to handle negative numbers correctly using two's complement is provided below.

4. **Large Positive Integer:**
   - Input: 12345
   - Expected Output: 11000000111001

5. **Minimum Integer Value (Corner Case):**
   - Input: Integer.MIN_VALUE (-2147483648)
   - Expected Output: 10000000000000000000000000000000 (This requires correct two's complement handling).



**Modified Code to Handle Negative Numbers:**

```java
import java.util.Scanner;

public class IntegerToBinary {

    public static String FunctionOne(int n) {
        if (n == 0) {
            return "0";
        }

        boolean isNegative = n < 0;
        if (isNegative) {
            n = -n; // Make n positive for processing
        }

        StringBuilder binary = new StringBuilder();
        while (n > 0) {
            binary.insert(0, n % 2);
            n /= 2;
        }


        if (isNegative) {  // Two's complement for negative numbers
            // 1. Invert bits
            for (int i = 0; i < binary.length(); i++) {
                binary.setCharAt(i, (binary.charAt(i) == '0') ? '1' : '0');
            }

            // 2. Add 1
            int carry = 1;
            for (int i = binary.length() - 1; i >= 0; i--) {
                if (binary.charAt(i) == '1' && carry == 1) {
                    binary.setCharAt(i, '0');
                } else if (binary.charAt(i) == '0' && carry == 1) {
                    binary.setCharAt(i, '1');
                    carry = 0;
                }
            }
            if (carry == 1) { // If overflow, add '1' at the beginning. 
                binary.insert(0, '1');
            }
           
            // Pad to 32 bits if negative
            while (binary.length() < 32) {
               binary.insert(0, '1'); // Pad with '1' for negative
            }


        }

        return binary.toString();
    }



    public static void main(String[] args) {
        // ... (same main method as before)
    }
}
```


This enhanced version now correctly handles negative numbers using the two's complement representation and provides a more comprehensive solution.  It also pads negative numbers to 32-bits as expected in Java's integer representation. Remember to test with the provided test cases, paying special attention to the corner cases like Integer.MIN_VALUE and 0.

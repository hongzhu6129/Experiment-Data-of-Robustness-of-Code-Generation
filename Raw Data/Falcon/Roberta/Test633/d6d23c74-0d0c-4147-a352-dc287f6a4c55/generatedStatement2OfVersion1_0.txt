

**Test Cases:**

| Binary Input | Expected Decimal Output | Expected Hexadecimal Output | Remarks |
|---|---|---|---|
| "1101" | 13 | 'd' | Valid input |
| "101010" | 42 | '2a' | Valid input |
| "1" | 1 | '1' | Valid input (single digit) |
| "0" | 0 | '0' | Valid input (zero) |
| "" | 0 | '0' | Valid input (empty string, treated as 0) |
| "101a10" | Invalid binary input... |  | Invalid input (contains 'a') |
| "11111111" | 255 | 'ff' | Valid input (maximum 8-bit value) |
| "100000000" | 256 | '100' | Valid input (9-bit value) |  
| "11111111111111111111111111111111" | 2147483647  | '7fffffff' | Valid input (Maximum 32-bit Integer) |
| "10000000000000000000000000000000" | -2147483648 | '80000000'| Corner case: Overflow (33 bits results in the minimum integer value due to two's complement representation). Expecting hex output could be problematic as well due to the negative sign. | 
| "12345" | Invalid binary input... | | Invalid input (contains non-binary digits) |



**Explanation of Corner Cases:**

* **Empty String:** An empty string is treated as 0, which is a reasonable default behavior.
* **Maximum Values:** Testing with the maximum 8-bit, and 32-bit integer values ensures the program handles large numbers correctly.
* **Overflow:**  The overflow case demonstrates what happens when the binary number represents a value larger than what an `int` can hold in Java.  This is important to understand how the program behaves in such situations (wraps around to the negative minimum due to two's complement representation).
* **Invalid Characters:**  Testing with non-binary characters ('a', '2', etc.) confirms that the program correctly identifies and handles invalid input.


This enhanced set of test cases provides more comprehensive coverage for the binary-to-decimal conversion program, including important boundary conditions and error handling scenarios.

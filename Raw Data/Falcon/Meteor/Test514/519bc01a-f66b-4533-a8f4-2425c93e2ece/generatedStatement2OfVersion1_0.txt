

**Test Cases:**

1. **Valid Binary Number:**
   Input: `101101`
   Expected Output: `45`

2. **Binary Number with Leading Zeros:**
   Input: `000101`
   Expected Output: `5`

3. **Single Digit Binary Number (1):**
   Input: `1`
   Expected Output: `1`

4. **Single Digit Binary Number (0):**
   Input: `0`
   Expected Output: `0`

5. **Empty String:**
   Input: ``
   Expected Output: `0`  (Considered a valid input representing 0)

6. **Invalid Binary String (contains non-binary characters):**
   Input: `10A10`
   Expected Output: `Invalid binary number. Please enter a valid binary string (containing only 0s and 1s).`

7. **Invalid Binary String (contains spaces):**
   Input: `10 10`
   Expected Output: `Invalid binary number. Please enter a valid binary string (containing only 0s and 1s).`

8. **Large Binary Number:** 
   Input: `1111111111111111111111111111111` (31 ones - the maximum an `int` can hold)
   Expected Output: `2147483647`

9. **Binary Number that would overflow `int`:**
   Input: `10000000000000000000000000000000` (32 bits - one more than `int` can hold)
   Expected Output: Might give a negative result or an incorrect positive result due to integer overflow in the `Math.pow()` calculation.  Consider using `long` if you need to handle very large binary inputs.


These test cases cover a range of scenarios, including valid inputs, invalid inputs, boundary conditions, and potential error cases (like overflow and non-binary characters). They help verify the robustness and correctness of the `BinaryToDecimal` program.

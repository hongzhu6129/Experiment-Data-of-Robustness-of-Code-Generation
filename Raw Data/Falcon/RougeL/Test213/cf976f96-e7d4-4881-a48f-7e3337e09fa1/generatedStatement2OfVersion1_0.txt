

**Test Cases:**

**1. Basic Case:**
   - Input:  {1, 2, 3, 4}  (as provided in the original code)
   - Expected Output:  24 unique three-digit numbers (4 * 3 * 2 = 24 permutations) and the numbers themselves printed.

**2. Repeated Digits:**
   - Input: {1, 1, 2, 3}
   - Expected Output: 12 unique three-digit numbers.  (Because the repeated '1' reduces the number of truly unique combinations).  Make sure the output doesn't include duplicates like 112 and 112.

**3. Fewer Digits:**
   - Input: {1, 2, 3}
   - Expected Output: 6 unique three-digit numbers (3 * 2 * 1 = 6).

**4. More Digits (Doesn't affect the 3-digit requirement):**
   - Input: {1, 2, 3, 4, 5}
   - Expected Output: Still 24 unique three-digit numbers. The extra digits won't be used because we're only forming 3-digit numbers.

**5. Empty Input (Corner Case):**
   - Input: {}
   - Expected Output: 0 unique three-digit numbers and no numbers printed.  Handle this gracefully without crashing. (The current code already handles this).

**6. Input with One or Two Digits (Corner Case):**
   - Input: {1} or {1, 2}
   - Expected Output: 0 unique three-digit numbers. You can't form a three-digit number with fewer than three unique digits. (The current code handles this).


**How to run the test cases:**

You can manually modify the `digits` array in the `main` method to test these different scenarios.  For more robust testing, consider using a testing framework like JUnit to automate these tests.  Here's a simple JUnit example:


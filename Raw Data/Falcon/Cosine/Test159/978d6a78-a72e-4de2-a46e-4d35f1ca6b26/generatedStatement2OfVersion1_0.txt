

**Test Cases:**

1. **Valid Binary Number:**
   - Input: `1101`
   - Expected Output: `Hexadecimal equivalent: D`

2. **Leading Zeros:**
   - Input: `0001101`
   - Expected Output: `Hexadecimal equivalent: D`

3. **Binary Number with Zero:**
   - Input: `1000`
   - Expected Output: `Hexadecimal equivalent: 8`

4. **Zero:**
   - Input: `0`
   - Expected Output: `Hexadecimal equivalent: 0`


5. **Invalid Binary Number (Contains other digits):**
   - Input: `1121`
   - Expected Output: `Invalid binary number.`

6. **Invalid Binary Number (Empty String):**
   - Input: `` (empty string)
   - Expected Output:  `Hexadecimal equivalent: 0` (because decimal will initially be 0) � Alternatively, you could specifically check for an empty string and print an "invalid input" message.


7. **Large Binary Number:**
   - Input: `1111111111111111` (16 ones)
   - Expected Output: `Hexadecimal equivalent: FFFF`

8. **Very Large Binary Number (to check for potential overflow issues):**
   - Input:  A very long string of 1s (e.g., 64 ones)
   - Expected Output: The correct hexadecimal equivalent or, if `int` overflows, unexpected behavior (which highlights a limitation � consider using `long` for very large binary inputs).


These test cases cover various scenarios, including valid binary inputs, invalid inputs, edge cases (zero, empty string), and a large binary number to test for potential overflow issues if the input binary string is extremely long.  Remember that using `int` limits the size of the binary number you can handle. If you anticipate very large binary numbers, use `long` instead.

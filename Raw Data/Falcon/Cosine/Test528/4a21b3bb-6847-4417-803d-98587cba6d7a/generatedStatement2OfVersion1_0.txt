


**Test Cases (including corner/edge cases):**

1. **Provided Example:**
   - lat1: 25
   - lon1: 35
   - lat2: 35.5
   - lon2: 25.5
   - Expected Output: ~1480.08 km

2. **Same Point:**
   - lat1: 45
   - lon1: 10
   - lat2: 45
   - lon2: 10
   - Expected Output: 0 km

3. **North and South Poles:**
   - lat1: 90  (North Pole)
   - lon1: 0  (Longitude irrelevant at poles)
   - lat2: -90 (South Pole)
   - lon2: 0  (Longitude irrelevant at poles)
   - Expected Output: ~20015.08 km (approximately Earth's circumference / 2)

4. **Antipodes (opposite sides of the Earth):**
   - lat1: 30
   - lon1: 40
   - lat2: -30
   - lon2: 180 + 40 = 220 (or -140 which is equivalent)
   - Expected Output: ~20015.08 km (approximately Earth's circumference / 2)

5. **Points near the 180th Meridian (International Date Line):**
   - lat1: 10
   - lon1: 179
   - lat2: 10
   - lon2: -179 
   - Expected Output: A small distance (as these points are close despite the longitude difference).


6. **Zero Longitude and Latitude:**
   - lat1: 0
   - lon1: 0
   - lat2: 10
   - lon2: 10
   - Expected Output: ~1234.5 km


7. **Large Longitude Difference, Same Latitude:**
    - lat1: 45
    - lon1: -170
    - lat2: 45
    - lon2: 170
    - Expected Output: A relatively small distance, as these points are close.

8. **Invalid Input (Optional):**  You could add tests for inputs outside the valid ranges for latitude (-90 to 90) and longitude (-180 to 180).  The best way to handle this depends on your specific requirements. You could either throw an exception or clamp the values to the valid range.


By running your Java program with these test cases, you can verify its correctness and handle potential edge cases, ensuring accurate distance calculations. Remember to compare the calculated distances with expected values within a reasonable tolerance due to floating-point precision limitations.

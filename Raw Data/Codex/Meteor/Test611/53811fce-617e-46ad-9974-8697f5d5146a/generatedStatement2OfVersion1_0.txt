

**Test Cases:**

Here are some test cases covering various scenarios, including corner cases:

| Test Case | Binary Number 1 | Binary Number 2 | Expected Output |
|---|---|---|---|
| 1 | "11" | "1" | "100" |
| 2 | "1010" | "1011" | "10101" |
| 3 | "1111" | "1111" | "11110" |  // Max values for 4 bits
| 4 | "0" | "0" | "0" |      // All zeros
| 5 | "1" | "0" | "1" |      // One operand is zero
| 6 | "0" | "1" | "1" |      // One operand is zero (other way)
| 7 | "" | "" | "" |        // Both empty strings (should handle gracefully)
| 8 | "111" | "" | "111" |   // One empty string
| 9 | "" | "101" | "101" |   // One empty string (other way)
| 10 | "100000000" | "1" | "100000001" | // Carry propagation over many bits
| 11| "11111111" | "1" | "100000000" |// Overflow to a new bit (8-bit example) 
| 12 | "10101010" | "01010101" | "11111111" | // Alternating bits
| 13 | "11" | "11" | "110"|


**How to Run Test Cases:**

1. **Manually:** You can input the binary numbers from the test cases into the program and verify the output against the expected output.
2. **JUnit (Recommended):** Create a separate test class (e.g., `AddBinaryTest.java`) and use JUnit assertions to automate the test cases. This is a more robust and efficient approach.


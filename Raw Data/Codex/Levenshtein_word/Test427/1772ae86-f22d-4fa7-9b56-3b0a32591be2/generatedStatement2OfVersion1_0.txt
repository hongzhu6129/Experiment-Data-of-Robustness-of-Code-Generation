

**Test Cases:**

Here are some test cases covering various scenarios, including corner cases:

1. **Provided Example:**
   - lat1: 25
   - lon1: 35
   - lat2: 35.5
   - lon2: 25.5
   - Expected Output: ~1480.08 km

2. **Same Point:**
   - lat1: 40
   - lon1: -70
   - lat2: 40
   - lon2: -70
   - Expected Output: 0 km

3. **North and South Poles:**
   - lat1: 90  (North Pole)
   - lon1: 0 
   - lat2: -90 (South Pole)
   - lon2: 0  (Longitude doesn't matter at poles)
   - Expected Output: ~20015.08 km (approximately Earth's circumference / 2)


4. **Antipodes (opposite points on the globe):**
   - lat1: 40
   - lon1: -70
   - lat2: -40
   - lon2: 110  (180 degrees opposite longitude)
   - Expected Output: ~20015.08 km (approximately Earth's circumference / 2)


5. **Points on the Equator:**
   - lat1: 0
   - lon1: 0
   - lat2: 0
   - lon2: 90
   - Expected Output: ~10007.54 km (approximately Earth's circumference / 4)

6. **Points near the International Date Line:**
   - lat1: 10
   - lon1: 179
   - lat2: 10
   - lon2: -179
   - Expected Output:  A small distance (because these points are close despite the longitude difference)


7. **Invalid Input (optional):** You could add tests to handle invalid input gracefully (e.g., latitude outside the range -90 to +90, non-numeric input). This would involve adding error handling (e.g., `try-catch` blocks) to your Java code.


**How to Run Test Cases:**

You can manually enter these values into your program.  For a more automated approach, you could create a separate test class using a testing framework like JUnit.  JUnit allows you to write test methods that call your distance calculation function with different inputs and assert that the output matches the expected value. This is good practice for larger projects.






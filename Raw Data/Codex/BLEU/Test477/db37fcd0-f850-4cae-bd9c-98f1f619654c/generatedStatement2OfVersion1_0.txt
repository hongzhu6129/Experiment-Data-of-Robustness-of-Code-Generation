

**Test Cases:**

1. **Valid Binary:**
   - Input: `101101`
   - Expected Output: `55`

2. **Leading Zeros:**
   - Input: `000111`  
   - Expected Output: `7`

3. **Zero:**
   - Input: `0`
   - Expected Output: `0`

4. **Large Binary:**
   - Input: `1111111111111111111111111111111` (31 ones - max for signed integer)
   - Expected Output: `37777777777`

5. **Invalid Input (Non-binary characters):**
   - Input: `101201`
   - Expected Output: `Invalid binary input.`

6. **Invalid Input (Empty String):**
   - Input: ``
   - Expected Output: (The program handles this gracefully and will produce an octal output of 0, as the decimal equivalent would be 0. You could add an explicit check for empty string if desired)

7. **Boundary Case (Max positive int represented in Binary):**
   - Input: `111111111111111111111111111111` (31 ones, excluding the sign bit which we assume here)
   - Expected Output: `17777777777`



This enhanced version includes input validation and handles corner cases like leading zeros, zero input, and invalid input effectively.  It also includes comments to clarify the logic.  It avoids any built-in library functions apart from `System.out.println` and `Scanner` (which is really needed for user input).

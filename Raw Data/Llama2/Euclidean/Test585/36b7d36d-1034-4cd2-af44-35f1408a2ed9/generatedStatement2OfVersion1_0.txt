


Explanation:

1. **Method 1: Sorting:**
   - Sort the array in ascending order using `Arrays.sort()`.
   - The last `k` elements of the sorted array will be the `k` largest elements.

2. **Method 2: Min-Heap (Priority Queue):**
   - Use a `PriorityQueue` (which is implemented as a min-heap in Java) to store the `k` largest elements encountered so far.
   - Iterate through the array:
     - If the heap size is less than `k`, add the current element to the heap.
     - If the heap size is equal to `k` and the current element is greater than the smallest element in the heap (the root of the min-heap), remove the smallest element and add the current element.
   - After iterating through the array, the elements remaining in the heap will be the `k` largest elements.  Retrieving the elements from a `PriorityQueue` will give them to you in ascending order (because it is a *min-*heap), so be aware of the order if that matters for your particular use case.

3. **Method 3: QuickSelect (Not implemented in the above code due to complexity):**
   - QuickSelect is an algorithm based on the QuickSort algorithm, which can find the kth smallest (or largest) element in an array efficiently on average.  It's generally the most efficient approach if you only need the kth largest element and don't need all k largest elements in sorted order.  However, since we have the constraint of implementing everything within the `main` method, it becomes cumbersome to implement recursive helper functions that QuickSelect typically requires.




Example Usage (in the `main` method itself):

